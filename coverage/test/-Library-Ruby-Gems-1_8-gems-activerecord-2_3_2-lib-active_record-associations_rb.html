<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/activerecord-2.3.2/lib/active_record/associations.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Thu Sep 24 15:05:00 +1000 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-activerecord-2_3_2-lib-active_record-associations_rb.html'>/Library/Ruby/Gems/1.8/gems/activerecord-2.3.2/lib/active_record/associations.rb</a>
        </td>
      <td class='lines_total'><tt>2169</tt>
        </td>
      <td class='lines_code'><tt>951</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>65.0%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='65'/>
                  <td class='uncovered' width='35'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>26.9%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='27'/>
                  <td class='uncovered' width='73'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked1"><a name="line1"></a>   1 module ActiveRecord
</span><span class="marked0"><a name="line2"></a>   2   class HasManyThroughAssociationNotFoundError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line3"></a>   3     def initialize(owner_class_name, reflection)
</span><span class="uncovered0"><a name="line4"></a>   4       super(&quot;Could not find the association #{reflection.options[:through].inspect} in model #{owner_class_name}&quot;)
</span><span class="uncovered1"><a name="line5"></a>   5     end
</span><span class="uncovered0"><a name="line6"></a>   6   end
</span><span class="inferred1"><a name="line7"></a>   7 
</span><span class="marked0"><a name="line8"></a>   8   class HasManyThroughAssociationPolymorphicError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line9"></a>   9     def initialize(owner_class_name, reflection, source_reflection)
</span><span class="uncovered0"><a name="line10"></a>  10       super(&quot;Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' on the polymorphic object '#{source_reflection.class_name}##{source_reflection.name}'.&quot;)
</span><span class="uncovered1"><a name="line11"></a>  11     end
</span><span class="uncovered0"><a name="line12"></a>  12   end
</span><span class="inferred1"><a name="line13"></a>  13 
</span><span class="marked0"><a name="line14"></a>  14   class HasManyThroughAssociationPointlessSourceTypeError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line15"></a>  15     def initialize(owner_class_name, reflection, source_reflection)
</span><span class="uncovered0"><a name="line16"></a>  16       super(&quot;Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' with a :source_type option if the '#{reflection.through_reflection.class_name}##{source_reflection.name}' is not polymorphic.  Try removing :source_type on your association.&quot;)
</span><span class="uncovered1"><a name="line17"></a>  17     end
</span><span class="uncovered0"><a name="line18"></a>  18   end
</span><span class="inferred1"><a name="line19"></a>  19 
</span><span class="marked0"><a name="line20"></a>  20   class HasManyThroughSourceAssociationNotFoundError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line21"></a>  21     def initialize(reflection)
</span><span class="uncovered0"><a name="line22"></a>  22       through_reflection      = reflection.through_reflection
</span><span class="uncovered1"><a name="line23"></a>  23       source_reflection_names = reflection.source_reflection_names
</span><span class="uncovered0"><a name="line24"></a>  24       source_associations     = reflection.through_reflection.klass.reflect_on_all_associations.collect { |a| a.name.inspect }
</span><span class="uncovered1"><a name="line25"></a>  25       super(&quot;Could not find the source association(s) #{source_reflection_names.collect(&amp;:inspect).to_sentence(:two_words_connector =&gt; ' or ', :last_word_connector =&gt; ', or ', :locale =&gt; :en)} in model #{through_reflection.klass}.  Try 'has_many #{reflection.name.inspect}, :through =&gt; #{through_reflection.name.inspect}, :source =&gt; &lt;name&gt;'.  Is it one of #{source_associations.to_sentence(:two_words_connector =&gt; ' or ', :last_word_connector =&gt; ', or ', :locale =&gt; :en)}?&quot;)
</span><span class="uncovered0"><a name="line26"></a>  26     end
</span><span class="uncovered1"><a name="line27"></a>  27   end
</span><span class="inferred0"><a name="line28"></a>  28 
</span><span class="marked1"><a name="line29"></a>  29   class HasManyThroughSourceAssociationMacroError &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line30"></a>  30     def initialize(reflection)
</span><span class="uncovered1"><a name="line31"></a>  31       through_reflection = reflection.through_reflection
</span><span class="uncovered0"><a name="line32"></a>  32       source_reflection  = reflection.source_reflection
</span><span class="uncovered1"><a name="line33"></a>  33       super(&quot;Invalid source reflection macro :#{source_reflection.macro}#{&quot; :through&quot; if source_reflection.options[:through]} for has_many #{reflection.name.inspect}, :through =&gt; #{through_reflection.name.inspect}.  Use :source to specify the source reflection.&quot;)
</span><span class="uncovered0"><a name="line34"></a>  34     end
</span><span class="uncovered1"><a name="line35"></a>  35   end
</span><span class="inferred0"><a name="line36"></a>  36 
</span><span class="marked1"><a name="line37"></a>  37   class HasManyThroughCantAssociateThroughHasManyReflection &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line38"></a>  38     def initialize(owner, reflection)
</span><span class="uncovered1"><a name="line39"></a>  39       super(&quot;Cannot modify association '#{owner.class.name}##{reflection.name}' because the source reflection class '#{reflection.source_reflection.class_name}' is associated to '#{reflection.through_reflection.class_name}' via :#{reflection.source_reflection.macro}.&quot;)
</span><span class="uncovered0"><a name="line40"></a>  40     end
</span><span class="uncovered1"><a name="line41"></a>  41   end
</span><span class="marked0"><a name="line42"></a>  42   class HasManyThroughCantAssociateNewRecords &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line43"></a>  43     def initialize(owner, reflection)
</span><span class="uncovered0"><a name="line44"></a>  44       super(&quot;Cannot associate new records through '#{owner.class.name}##{reflection.name}' on '#{reflection.source_reflection.class_name rescue nil}##{reflection.source_reflection.name rescue nil}'. Both records must have an id in order to create the has_many :through record associating them.&quot;)
</span><span class="uncovered1"><a name="line45"></a>  45     end
</span><span class="uncovered0"><a name="line46"></a>  46   end
</span><span class="inferred1"><a name="line47"></a>  47 
</span><span class="marked0"><a name="line48"></a>  48   class HasManyThroughCantDissociateNewRecords &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line49"></a>  49     def initialize(owner, reflection)
</span><span class="uncovered0"><a name="line50"></a>  50       super(&quot;Cannot dissociate new records through '#{owner.class.name}##{reflection.name}' on '#{reflection.source_reflection.class_name rescue nil}##{reflection.source_reflection.name rescue nil}'. Both records must have an id in order to delete the has_many :through record associating them.&quot;)
</span><span class="uncovered1"><a name="line51"></a>  51     end
</span><span class="uncovered0"><a name="line52"></a>  52   end
</span><span class="inferred1"><a name="line53"></a>  53 
</span><span class="marked0"><a name="line54"></a>  54   class HasAndBelongsToManyAssociationForeignKeyNeeded &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line55"></a>  55     def initialize(reflection)
</span><span class="uncovered0"><a name="line56"></a>  56       super(&quot;Cannot create self referential has_and_belongs_to_many association on '#{reflection.class_name rescue nil}##{reflection.name rescue nil}'. :association_foreign_key cannot be the same as the :foreign_key.&quot;)
</span><span class="uncovered1"><a name="line57"></a>  57     end
</span><span class="uncovered0"><a name="line58"></a>  58   end
</span><span class="inferred1"><a name="line59"></a>  59 
</span><span class="marked0"><a name="line60"></a>  60   class EagerLoadPolymorphicError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line61"></a>  61     def initialize(reflection)
</span><span class="uncovered0"><a name="line62"></a>  62       super(&quot;Can not eagerly load the polymorphic association #{reflection.name.inspect}&quot;)
</span><span class="uncovered1"><a name="line63"></a>  63     end
</span><span class="uncovered0"><a name="line64"></a>  64   end
</span><span class="inferred1"><a name="line65"></a>  65 
</span><span class="marked0"><a name="line66"></a>  66   class ReadOnlyAssociation &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line67"></a>  67     def initialize(reflection)
</span><span class="uncovered0"><a name="line68"></a>  68       super(&quot;Can not add to a has_many :through association.  Try adding to #{reflection.through_reflection.name.inspect}.&quot;)
</span><span class="uncovered1"><a name="line69"></a>  69     end
</span><span class="uncovered0"><a name="line70"></a>  70   end
</span><span class="inferred1"><a name="line71"></a>  71 
</span><span class="inferred0"><a name="line72"></a>  72   # See ActiveRecord::Associations::ClassMethods for documentation.
</span><span class="marked1"><a name="line73"></a>  73   module Associations # :nodoc:
</span><span class="inferred0"><a name="line74"></a>  74     # These classes will be loaded when associations are created.
</span><span class="inferred1"><a name="line75"></a>  75     # So there is no need to eager load them.
</span><span class="marked0"><a name="line76"></a>  76     autoload :AssociationCollection, 'active_record/associations/association_collection'
</span><span class="marked1"><a name="line77"></a>  77     autoload :AssociationProxy, 'active_record/associations/association_proxy'
</span><span class="marked0"><a name="line78"></a>  78     autoload :BelongsToAssociation, 'active_record/associations/belongs_to_association'
</span><span class="marked1"><a name="line79"></a>  79     autoload :BelongsToPolymorphicAssociation, 'active_record/associations/belongs_to_polymorphic_association'
</span><span class="marked0"><a name="line80"></a>  80     autoload :HasAndBelongsToManyAssociation, 'active_record/associations/has_and_belongs_to_many_association'
</span><span class="marked1"><a name="line81"></a>  81     autoload :HasManyAssociation, 'active_record/associations/has_many_association'
</span><span class="marked0"><a name="line82"></a>  82     autoload :HasManyThroughAssociation, 'active_record/associations/has_many_through_association'
</span><span class="marked1"><a name="line83"></a>  83     autoload :HasOneAssociation, 'active_record/associations/has_one_association'
</span><span class="marked0"><a name="line84"></a>  84     autoload :HasOneThroughAssociation, 'active_record/associations/has_one_through_association'
</span><span class="inferred1"><a name="line85"></a>  85 
</span><span class="marked0"><a name="line86"></a>  86     def self.included(base)
</span><span class="marked1"><a name="line87"></a>  87       base.extend(ClassMethods)
</span><span class="marked0"><a name="line88"></a>  88     end
</span><span class="inferred1"><a name="line89"></a>  89 
</span><span class="inferred0"><a name="line90"></a>  90     # Clears out the association cache
</span><span class="marked1"><a name="line91"></a>  91     def clear_association_cache #:nodoc:
</span><span class="uncovered0"><a name="line92"></a>  92       self.class.reflect_on_all_associations.to_a.each do |assoc|
</span><span class="uncovered1"><a name="line93"></a>  93         instance_variable_set &quot;@#{assoc.name}&quot;, nil
</span><span class="uncovered0"><a name="line94"></a>  94       end unless self.new_record?
</span><span class="uncovered1"><a name="line95"></a>  95     end
</span><span class="inferred0"><a name="line96"></a>  96 
</span><span class="marked1"><a name="line97"></a>  97     private
</span><span class="inferred0"><a name="line98"></a>  98       # Gets the specified association instance if it responds to :loaded?, nil otherwise.
</span><span class="marked1"><a name="line99"></a>  99       def association_instance_get(name)
</span><span class="marked0"><a name="line100"></a> 100         association = instance_variable_get(&quot;@#{name}&quot;)
</span><span class="marked1"><a name="line101"></a> 101         association if association.respond_to?(:loaded?)
</span><span class="inferred0"><a name="line102"></a> 102       end
</span><span class="inferred1"><a name="line103"></a> 103 
</span><span class="inferred0"><a name="line104"></a> 104       # Set the specified association instance.
</span><span class="marked1"><a name="line105"></a> 105       def association_instance_set(name, association)
</span><span class="marked0"><a name="line106"></a> 106         instance_variable_set(&quot;@#{name}&quot;, association)
</span><span class="marked1"><a name="line107"></a> 107       end
</span><span class="inferred0"><a name="line108"></a> 108 
</span><span class="inferred1"><a name="line109"></a> 109     # Associations are a set of macro-like class methods for tying objects together through foreign keys. They express relationships like
</span><span class="inferred0"><a name="line110"></a> 110     # &quot;Project has one Project Manager&quot; or &quot;Project belongs to a Portfolio&quot;. Each macro adds a number of methods to the class which are
</span><span class="inferred1"><a name="line111"></a> 111     # specialized according to the collection or association symbol and the options hash. It works much the same way as Ruby's own &lt;tt&gt;attr*&lt;/tt&gt;
</span><span class="inferred0"><a name="line112"></a> 112     # methods. Example:
</span><span class="inferred1"><a name="line113"></a> 113     #
</span><span class="inferred0"><a name="line114"></a> 114     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line115"></a> 115     #     belongs_to              :portfolio
</span><span class="inferred0"><a name="line116"></a> 116     #     has_one                 :project_manager
</span><span class="inferred1"><a name="line117"></a> 117     #     has_many                :milestones
</span><span class="inferred0"><a name="line118"></a> 118     #     has_and_belongs_to_many :categories
</span><span class="inferred1"><a name="line119"></a> 119     #   end
</span><span class="inferred0"><a name="line120"></a> 120     #
</span><span class="inferred1"><a name="line121"></a> 121     # The project class now has the following methods (and more) to ease the traversal and manipulation of its relationships:
</span><span class="inferred0"><a name="line122"></a> 122     # * &lt;tt&gt;Project#portfolio, Project#portfolio=(portfolio), Project#portfolio.nil?&lt;/tt&gt;
</span><span class="inferred1"><a name="line123"></a> 123     # * &lt;tt&gt;Project#project_manager, Project#project_manager=(project_manager), Project#project_manager.nil?,&lt;/tt&gt;
</span><span class="inferred0"><a name="line124"></a> 124     # * &lt;tt&gt;Project#milestones.empty?, Project#milestones.size, Project#milestones, Project#milestones&lt;&lt;(milestone),&lt;/tt&gt;
</span><span class="inferred1"><a name="line125"></a> 125     #   &lt;tt&gt;Project#milestones.delete(milestone), Project#milestones.find(milestone_id), Project#milestones.find(:all, options),&lt;/tt&gt;
</span><span class="inferred0"><a name="line126"></a> 126     #   &lt;tt&gt;Project#milestones.build, Project#milestones.create&lt;/tt&gt;
</span><span class="inferred1"><a name="line127"></a> 127     # * &lt;tt&gt;Project#categories.empty?, Project#categories.size, Project#categories, Project#categories&lt;&lt;(category1),&lt;/tt&gt;
</span><span class="inferred0"><a name="line128"></a> 128     #   &lt;tt&gt;Project#categories.delete(category1)&lt;/tt&gt;
</span><span class="inferred1"><a name="line129"></a> 129     #
</span><span class="inferred0"><a name="line130"></a> 130     # === A word of warning
</span><span class="inferred1"><a name="line131"></a> 131     #
</span><span class="inferred0"><a name="line132"></a> 132     # Don't create associations that have the same name as instance methods of ActiveRecord::Base. Since the association
</span><span class="inferred1"><a name="line133"></a> 133     # adds a method with that name to its model, it will override the inherited method and break things.
</span><span class="inferred0"><a name="line134"></a> 134     # For instance, +attributes+ and +connection+ would be bad choices for association names.
</span><span class="inferred1"><a name="line135"></a> 135     #
</span><span class="inferred0"><a name="line136"></a> 136     # == Auto-generated methods
</span><span class="inferred1"><a name="line137"></a> 137     #
</span><span class="inferred0"><a name="line138"></a> 138     # === Singular associations (one-to-one)
</span><span class="inferred1"><a name="line139"></a> 139     #                                     |            |  belongs_to  |
</span><span class="inferred0"><a name="line140"></a> 140     #   generated methods                 | belongs_to | :polymorphic | has_one
</span><span class="inferred1"><a name="line141"></a> 141     #   ----------------------------------+------------+--------------+---------
</span><span class="inferred0"><a name="line142"></a> 142     #   other                             |     X      |      X       |    X
</span><span class="inferred1"><a name="line143"></a> 143     #   other=(other)                     |     X      |      X       |    X
</span><span class="inferred0"><a name="line144"></a> 144     #   build_other(attributes={})        |     X      |              |    X
</span><span class="inferred1"><a name="line145"></a> 145     #   create_other(attributes={})       |     X      |              |    X
</span><span class="inferred0"><a name="line146"></a> 146     #   other.create!(attributes={})      |            |              |    X
</span><span class="inferred1"><a name="line147"></a> 147     #
</span><span class="inferred0"><a name="line148"></a> 148     # ===Collection associations (one-to-many / many-to-many)
</span><span class="inferred1"><a name="line149"></a> 149     #                                     |       |          | has_many
</span><span class="inferred0"><a name="line150"></a> 150     #   generated methods                 | habtm | has_many | :through
</span><span class="inferred1"><a name="line151"></a> 151     #   ----------------------------------+-------+----------+----------
</span><span class="inferred0"><a name="line152"></a> 152     #   others                            |   X   |    X     |    X
</span><span class="inferred1"><a name="line153"></a> 153     #   others=(other,other,...)          |   X   |    X     |    X
</span><span class="inferred0"><a name="line154"></a> 154     #   other_ids                         |   X   |    X     |    X
</span><span class="inferred1"><a name="line155"></a> 155     #   other_ids=(id,id,...)             |   X   |    X     |    X
</span><span class="inferred0"><a name="line156"></a> 156     #   others&lt;&lt;                          |   X   |    X     |    X
</span><span class="inferred1"><a name="line157"></a> 157     #   others.push                       |   X   |    X     |    X
</span><span class="inferred0"><a name="line158"></a> 158     #   others.concat                     |   X   |    X     |    X
</span><span class="inferred1"><a name="line159"></a> 159     #   others.build(attributes={})       |   X   |    X     |    X
</span><span class="inferred0"><a name="line160"></a> 160     #   others.create(attributes={})      |   X   |    X     |    X
</span><span class="inferred1"><a name="line161"></a> 161     #   others.create!(attributes={})     |   X   |    X     |    X
</span><span class="inferred0"><a name="line162"></a> 162     #   others.size                       |   X   |    X     |    X
</span><span class="inferred1"><a name="line163"></a> 163     #   others.length                     |   X   |    X     |    X
</span><span class="inferred0"><a name="line164"></a> 164     #   others.count                      |   X   |    X     |    X
</span><span class="inferred1"><a name="line165"></a> 165     #   others.sum(args*,&amp;block)          |   X   |    X     |    X
</span><span class="inferred0"><a name="line166"></a> 166     #   others.empty?                     |   X   |    X     |    X
</span><span class="inferred1"><a name="line167"></a> 167     #   others.clear                      |   X   |    X     |    X
</span><span class="inferred0"><a name="line168"></a> 168     #   others.delete(other,other,...)    |   X   |    X     |    X
</span><span class="inferred1"><a name="line169"></a> 169     #   others.delete_all                 |   X   |    X     |
</span><span class="inferred0"><a name="line170"></a> 170     #   others.destroy_all                |   X   |    X     |    X
</span><span class="inferred1"><a name="line171"></a> 171     #   others.find(*args)                |   X   |    X     |    X
</span><span class="inferred0"><a name="line172"></a> 172     #   others.find_first                 |   X   |          |
</span><span class="inferred1"><a name="line173"></a> 173     #   others.exists?                    |   X   |    X     |    X
</span><span class="inferred0"><a name="line174"></a> 174     #   others.uniq                       |   X   |    X     |    X
</span><span class="inferred1"><a name="line175"></a> 175     #   others.reset                      |   X   |    X     |    X
</span><span class="inferred0"><a name="line176"></a> 176     #
</span><span class="inferred1"><a name="line177"></a> 177     # == Cardinality and associations
</span><span class="inferred0"><a name="line178"></a> 178     #
</span><span class="inferred1"><a name="line179"></a> 179     # Active Record associations can be used to describe one-to-one, one-to-many and many-to-many
</span><span class="inferred0"><a name="line180"></a> 180     # relationships between models. Each model uses an association to describe its role in
</span><span class="inferred1"><a name="line181"></a> 181     # the relation. The +belongs_to+ association is always used in the model that has
</span><span class="inferred0"><a name="line182"></a> 182     # the foreign key.
</span><span class="inferred1"><a name="line183"></a> 183     #
</span><span class="inferred0"><a name="line184"></a> 184     # === One-to-one
</span><span class="inferred1"><a name="line185"></a> 185     #
</span><span class="inferred0"><a name="line186"></a> 186     # Use +has_one+ in the base, and +belongs_to+ in the associated model.
</span><span class="inferred1"><a name="line187"></a> 187     #
</span><span class="inferred0"><a name="line188"></a> 188     #   class Employee &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line189"></a> 189     #     has_one :office
</span><span class="inferred0"><a name="line190"></a> 190     #   end
</span><span class="inferred1"><a name="line191"></a> 191     #   class Office &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line192"></a> 192     #     belongs_to :employee    # foreign key - employee_id
</span><span class="inferred1"><a name="line193"></a> 193     #   end
</span><span class="inferred0"><a name="line194"></a> 194     #
</span><span class="inferred1"><a name="line195"></a> 195     # === One-to-many
</span><span class="inferred0"><a name="line196"></a> 196     #
</span><span class="inferred1"><a name="line197"></a> 197     # Use +has_many+ in the base, and +belongs_to+ in the associated model.
</span><span class="inferred0"><a name="line198"></a> 198     #
</span><span class="inferred1"><a name="line199"></a> 199     #   class Manager &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line200"></a> 200     #     has_many :employees
</span><span class="inferred1"><a name="line201"></a> 201     #   end
</span><span class="inferred0"><a name="line202"></a> 202     #   class Employee &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line203"></a> 203     #     belongs_to :manager     # foreign key - manager_id
</span><span class="inferred0"><a name="line204"></a> 204     #   end
</span><span class="inferred1"><a name="line205"></a> 205     #
</span><span class="inferred0"><a name="line206"></a> 206     # === Many-to-many
</span><span class="inferred1"><a name="line207"></a> 207     #
</span><span class="inferred0"><a name="line208"></a> 208     # There are two ways to build a many-to-many relationship.
</span><span class="inferred1"><a name="line209"></a> 209     #
</span><span class="inferred0"><a name="line210"></a> 210     # The first way uses a +has_many+ association with the &lt;tt&gt;:through&lt;/tt&gt; option and a join model, so
</span><span class="inferred1"><a name="line211"></a> 211     # there are two stages of associations.
</span><span class="inferred0"><a name="line212"></a> 212     #
</span><span class="inferred1"><a name="line213"></a> 213     #   class Assignment &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line214"></a> 214     #     belongs_to :programmer  # foreign key - programmer_id
</span><span class="inferred1"><a name="line215"></a> 215     #     belongs_to :project     # foreign key - project_id
</span><span class="inferred0"><a name="line216"></a> 216     #   end
</span><span class="inferred1"><a name="line217"></a> 217     #   class Programmer &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line218"></a> 218     #     has_many :assignments
</span><span class="inferred1"><a name="line219"></a> 219     #     has_many :projects, :through =&gt; :assignments
</span><span class="inferred0"><a name="line220"></a> 220     #   end
</span><span class="inferred1"><a name="line221"></a> 221     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line222"></a> 222     #     has_many :assignments
</span><span class="inferred1"><a name="line223"></a> 223     #     has_many :programmers, :through =&gt; :assignments
</span><span class="inferred0"><a name="line224"></a> 224     #   end
</span><span class="inferred1"><a name="line225"></a> 225     #
</span><span class="inferred0"><a name="line226"></a> 226     # For the second way, use +has_and_belongs_to_many+ in both models. This requires a join table
</span><span class="inferred1"><a name="line227"></a> 227     # that has no corresponding model or primary key.
</span><span class="inferred0"><a name="line228"></a> 228     #
</span><span class="inferred1"><a name="line229"></a> 229     #   class Programmer &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line230"></a> 230     #     has_and_belongs_to_many :projects       # foreign keys in the join table
</span><span class="inferred1"><a name="line231"></a> 231     #   end
</span><span class="inferred0"><a name="line232"></a> 232     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line233"></a> 233     #     has_and_belongs_to_many :programmers    # foreign keys in the join table
</span><span class="inferred0"><a name="line234"></a> 234     #   end
</span><span class="inferred1"><a name="line235"></a> 235     #
</span><span class="inferred0"><a name="line236"></a> 236     # Choosing which way to build a many-to-many relationship is not always simple.
</span><span class="inferred1"><a name="line237"></a> 237     # If you need to work with the relationship model as its own entity,
</span><span class="inferred0"><a name="line238"></a> 238     # use &lt;tt&gt;has_many :through&lt;/tt&gt;. Use +has_and_belongs_to_many+ when working with legacy schemas or when
</span><span class="inferred1"><a name="line239"></a> 239     # you never work directly with the relationship itself.
</span><span class="inferred0"><a name="line240"></a> 240     #
</span><span class="inferred1"><a name="line241"></a> 241     # == Is it a +belongs_to+ or +has_one+ association?
</span><span class="inferred0"><a name="line242"></a> 242     #
</span><span class="inferred1"><a name="line243"></a> 243     # Both express a 1-1 relationship. The difference is mostly where to place the foreign key, which goes on the table for the class
</span><span class="inferred0"><a name="line244"></a> 244     # declaring the +belongs_to+ relationship. Example:
</span><span class="inferred1"><a name="line245"></a> 245     #
</span><span class="inferred0"><a name="line246"></a> 246     #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line247"></a> 247     #     # I reference an account.
</span><span class="inferred0"><a name="line248"></a> 248     #     belongs_to :account
</span><span class="inferred1"><a name="line249"></a> 249     #   end
</span><span class="inferred0"><a name="line250"></a> 250     #
</span><span class="inferred1"><a name="line251"></a> 251     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line252"></a> 252     #     # One user references me.
</span><span class="inferred1"><a name="line253"></a> 253     #     has_one :user
</span><span class="inferred0"><a name="line254"></a> 254     #   end
</span><span class="inferred1"><a name="line255"></a> 255     #
</span><span class="inferred0"><a name="line256"></a> 256     # The tables for these classes could look something like:
</span><span class="inferred1"><a name="line257"></a> 257     #
</span><span class="inferred0"><a name="line258"></a> 258     #   CREATE TABLE users (
</span><span class="inferred1"><a name="line259"></a> 259     #     id int(11) NOT NULL auto_increment,
</span><span class="inferred0"><a name="line260"></a> 260     #     account_id int(11) default NULL,
</span><span class="inferred1"><a name="line261"></a> 261     #     name varchar default NULL,
</span><span class="inferred0"><a name="line262"></a> 262     #     PRIMARY KEY  (id)
</span><span class="inferred1"><a name="line263"></a> 263     #   )
</span><span class="inferred0"><a name="line264"></a> 264     #
</span><span class="inferred1"><a name="line265"></a> 265     #   CREATE TABLE accounts (
</span><span class="inferred0"><a name="line266"></a> 266     #     id int(11) NOT NULL auto_increment,
</span><span class="inferred1"><a name="line267"></a> 267     #     name varchar default NULL,
</span><span class="inferred0"><a name="line268"></a> 268     #     PRIMARY KEY  (id)
</span><span class="inferred1"><a name="line269"></a> 269     #   )
</span><span class="inferred0"><a name="line270"></a> 270     #
</span><span class="inferred1"><a name="line271"></a> 271     # == Unsaved objects and associations
</span><span class="inferred0"><a name="line272"></a> 272     #
</span><span class="inferred1"><a name="line273"></a> 273     # You can manipulate objects and associations before they are saved to the database, but there is some special behavior you should be
</span><span class="inferred0"><a name="line274"></a> 274     # aware of, mostly involving the saving of associated objects.
</span><span class="inferred1"><a name="line275"></a> 275     #
</span><span class="inferred0"><a name="line276"></a> 276     # Unless you enable the :autosave option on a &lt;tt&gt;has_one&lt;/tt&gt;, &lt;tt&gt;belongs_to&lt;/tt&gt;,
</span><span class="inferred1"><a name="line277"></a> 277     # &lt;tt&gt;has_many&lt;/tt&gt;, or &lt;tt&gt;has_and_belongs_to_many&lt;/tt&gt; association,
</span><span class="inferred0"><a name="line278"></a> 278     # in which case the members are always saved.
</span><span class="inferred1"><a name="line279"></a> 279     #
</span><span class="inferred0"><a name="line280"></a> 280     # === One-to-one associations
</span><span class="inferred1"><a name="line281"></a> 281     #
</span><span class="inferred0"><a name="line282"></a> 282     # * Assigning an object to a +has_one+ association automatically saves that object and the object being replaced (if there is one), in
</span><span class="inferred1"><a name="line283"></a> 283     #   order to update their primary keys - except if the parent object is unsaved (&lt;tt&gt;new_record? == true&lt;/tt&gt;).
</span><span class="inferred0"><a name="line284"></a> 284     # * If either of these saves fail (due to one of the objects being invalid) the assignment statement returns +false+ and the assignment
</span><span class="inferred1"><a name="line285"></a> 285     #   is cancelled.
</span><span class="inferred0"><a name="line286"></a> 286     # * If you wish to assign an object to a +has_one+ association without saving it, use the &lt;tt&gt;association.build&lt;/tt&gt; method (documented below).
</span><span class="inferred1"><a name="line287"></a> 287     # * Assigning an object to a +belongs_to+ association does not save the object, since the foreign key field belongs on the parent. It
</span><span class="inferred0"><a name="line288"></a> 288     #   does not save the parent either.
</span><span class="inferred1"><a name="line289"></a> 289     #
</span><span class="inferred0"><a name="line290"></a> 290     # === Collections
</span><span class="inferred1"><a name="line291"></a> 291     #
</span><span class="inferred0"><a name="line292"></a> 292     # * Adding an object to a collection (+has_many+ or +has_and_belongs_to_many+) automatically saves that object, except if the parent object
</span><span class="inferred1"><a name="line293"></a> 293     #   (the owner of the collection) is not yet stored in the database.
</span><span class="inferred0"><a name="line294"></a> 294     # * If saving any of the objects being added to a collection (via &lt;tt&gt;push&lt;/tt&gt; or similar) fails, then &lt;tt&gt;push&lt;/tt&gt; returns +false+.
</span><span class="inferred1"><a name="line295"></a> 295     # * You can add an object to a collection without automatically saving it by using the &lt;tt&gt;collection.build&lt;/tt&gt; method (documented below).
</span><span class="inferred0"><a name="line296"></a> 296     # * All unsaved (&lt;tt&gt;new_record? == true&lt;/tt&gt;) members of the collection are automatically saved when the parent is saved.
</span><span class="inferred1"><a name="line297"></a> 297     #
</span><span class="inferred0"><a name="line298"></a> 298     # === Association callbacks
</span><span class="inferred1"><a name="line299"></a> 299     #
</span><span class="inferred0"><a name="line300"></a> 300     # Similar to the normal callbacks that hook into the lifecycle of an Active Record object, you can also define callbacks that get
</span><span class="inferred1"><a name="line301"></a> 301     # triggered when you add an object to or remove an object from an association collection. Example:
</span><span class="inferred0"><a name="line302"></a> 302     #
</span><span class="inferred1"><a name="line303"></a> 303     #   class Project
</span><span class="inferred0"><a name="line304"></a> 304     #     has_and_belongs_to_many :developers, :after_add =&gt; :evaluate_velocity
</span><span class="inferred1"><a name="line305"></a> 305     #
</span><span class="inferred0"><a name="line306"></a> 306     #     def evaluate_velocity(developer)
</span><span class="inferred1"><a name="line307"></a> 307     #       ...
</span><span class="inferred0"><a name="line308"></a> 308     #     end
</span><span class="inferred1"><a name="line309"></a> 309     #   end
</span><span class="inferred0"><a name="line310"></a> 310     #
</span><span class="inferred1"><a name="line311"></a> 311     # It's possible to stack callbacks by passing them as an array. Example:
</span><span class="inferred0"><a name="line312"></a> 312     #
</span><span class="inferred1"><a name="line313"></a> 313     #   class Project
</span><span class="inferred0"><a name="line314"></a> 314     #     has_and_belongs_to_many :developers, :after_add =&gt; [:evaluate_velocity, Proc.new { |p, d| p.shipping_date = Time.now}]
</span><span class="inferred1"><a name="line315"></a> 315     #   end
</span><span class="inferred0"><a name="line316"></a> 316     #
</span><span class="inferred1"><a name="line317"></a> 317     # Possible callbacks are: +before_add+, +after_add+, +before_remove+ and +after_remove+.
</span><span class="inferred0"><a name="line318"></a> 318     #
</span><span class="inferred1"><a name="line319"></a> 319     # Should any of the +before_add+ callbacks throw an exception, the object does not get added to the collection. Same with
</span><span class="inferred0"><a name="line320"></a> 320     # the +before_remove+ callbacks; if an exception is thrown the object doesn't get removed.
</span><span class="inferred1"><a name="line321"></a> 321     #
</span><span class="inferred0"><a name="line322"></a> 322     # === Association extensions
</span><span class="inferred1"><a name="line323"></a> 323     #
</span><span class="inferred0"><a name="line324"></a> 324     # The proxy objects that control the access to associations can be extended through anonymous modules. This is especially
</span><span class="inferred1"><a name="line325"></a> 325     # beneficial for adding new finders, creators, and other factory-type methods that are only used as part of this association.
</span><span class="inferred0"><a name="line326"></a> 326     # Example:
</span><span class="inferred1"><a name="line327"></a> 327     #
</span><span class="inferred0"><a name="line328"></a> 328     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line329"></a> 329     #     has_many :people do
</span><span class="inferred0"><a name="line330"></a> 330     #       def find_or_create_by_name(name)
</span><span class="inferred1"><a name="line331"></a> 331     #         first_name, last_name = name.split(&quot; &quot;, 2)
</span><span class="inferred0"><a name="line332"></a> 332     #         find_or_create_by_first_name_and_last_name(first_name, last_name)
</span><span class="inferred1"><a name="line333"></a> 333     #       end
</span><span class="inferred0"><a name="line334"></a> 334     #     end
</span><span class="inferred1"><a name="line335"></a> 335     #   end
</span><span class="inferred0"><a name="line336"></a> 336     #
</span><span class="inferred1"><a name="line337"></a> 337     #   person = Account.find(:first).people.find_or_create_by_name(&quot;David Heinemeier Hansson&quot;)
</span><span class="inferred0"><a name="line338"></a> 338     #   person.first_name # =&gt; &quot;David&quot;
</span><span class="inferred1"><a name="line339"></a> 339     #   person.last_name  # =&gt; &quot;Heinemeier Hansson&quot;
</span><span class="inferred0"><a name="line340"></a> 340     #
</span><span class="inferred1"><a name="line341"></a> 341     # If you need to share the same extensions between many associations, you can use a named extension module. Example:
</span><span class="inferred0"><a name="line342"></a> 342     #
</span><span class="inferred1"><a name="line343"></a> 343     #   module FindOrCreateByNameExtension
</span><span class="inferred0"><a name="line344"></a> 344     #     def find_or_create_by_name(name)
</span><span class="inferred1"><a name="line345"></a> 345     #       first_name, last_name = name.split(&quot; &quot;, 2)
</span><span class="inferred0"><a name="line346"></a> 346     #       find_or_create_by_first_name_and_last_name(first_name, last_name)
</span><span class="inferred1"><a name="line347"></a> 347     #     end
</span><span class="inferred0"><a name="line348"></a> 348     #   end
</span><span class="inferred1"><a name="line349"></a> 349     #
</span><span class="inferred0"><a name="line350"></a> 350     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line351"></a> 351     #     has_many :people, :extend =&gt; FindOrCreateByNameExtension
</span><span class="inferred0"><a name="line352"></a> 352     #   end
</span><span class="inferred1"><a name="line353"></a> 353     #
</span><span class="inferred0"><a name="line354"></a> 354     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line355"></a> 355     #     has_many :people, :extend =&gt; FindOrCreateByNameExtension
</span><span class="inferred0"><a name="line356"></a> 356     #   end
</span><span class="inferred1"><a name="line357"></a> 357     #
</span><span class="inferred0"><a name="line358"></a> 358     # If you need to use multiple named extension modules, you can specify an array of modules with the &lt;tt&gt;:extend&lt;/tt&gt; option.
</span><span class="inferred1"><a name="line359"></a> 359     # In the case of name conflicts between methods in the modules, methods in modules later in the array supercede
</span><span class="inferred0"><a name="line360"></a> 360     # those earlier in the array. Example:
</span><span class="inferred1"><a name="line361"></a> 361     #
</span><span class="inferred0"><a name="line362"></a> 362     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line363"></a> 363     #     has_many :people, :extend =&gt; [FindOrCreateByNameExtension, FindRecentExtension]
</span><span class="inferred0"><a name="line364"></a> 364     #   end
</span><span class="inferred1"><a name="line365"></a> 365     #
</span><span class="inferred0"><a name="line366"></a> 366     # Some extensions can only be made to work with knowledge of the association proxy's internals.
</span><span class="inferred1"><a name="line367"></a> 367     # Extensions can access relevant state using accessors on the association proxy:
</span><span class="inferred0"><a name="line368"></a> 368     #
</span><span class="inferred1"><a name="line369"></a> 369     # * +proxy_owner+ - Returns the object the association is part of.
</span><span class="inferred0"><a name="line370"></a> 370     # * +proxy_reflection+ - Returns the reflection object that describes the association.
</span><span class="inferred1"><a name="line371"></a> 371     # * +proxy_target+ - Returns the associated object for +belongs_to+ and +has_one+, or the collection of associated objects for +has_many+ and +has_and_belongs_to_many+.
</span><span class="inferred0"><a name="line372"></a> 372     #
</span><span class="inferred1"><a name="line373"></a> 373     # === Association Join Models
</span><span class="inferred0"><a name="line374"></a> 374     #
</span><span class="inferred1"><a name="line375"></a> 375     # Has Many associations can be configured with the &lt;tt&gt;:through&lt;/tt&gt; option to use an explicit join model to retrieve the data.  This
</span><span class="inferred0"><a name="line376"></a> 376     # operates similarly to a +has_and_belongs_to_many+ association.  The advantage is that you're able to add validations,
</span><span class="inferred1"><a name="line377"></a> 377     # callbacks, and extra attributes on the join model.  Consider the following schema:
</span><span class="inferred0"><a name="line378"></a> 378     #
</span><span class="inferred1"><a name="line379"></a> 379     #   class Author &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line380"></a> 380     #     has_many :authorships
</span><span class="inferred1"><a name="line381"></a> 381     #     has_many :books, :through =&gt; :authorships
</span><span class="inferred0"><a name="line382"></a> 382     #   end
</span><span class="inferred1"><a name="line383"></a> 383     #
</span><span class="inferred0"><a name="line384"></a> 384     #   class Authorship &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line385"></a> 385     #     belongs_to :author
</span><span class="inferred0"><a name="line386"></a> 386     #     belongs_to :book
</span><span class="inferred1"><a name="line387"></a> 387     #   end
</span><span class="inferred0"><a name="line388"></a> 388     #
</span><span class="inferred1"><a name="line389"></a> 389     #   @author = Author.find :first
</span><span class="inferred0"><a name="line390"></a> 390     #   @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to.
</span><span class="inferred1"><a name="line391"></a> 391     #   @author.books                              # selects all books by using the Authorship join model
</span><span class="inferred0"><a name="line392"></a> 392     #
</span><span class="inferred1"><a name="line393"></a> 393     # You can also go through a +has_many+ association on the join model:
</span><span class="inferred0"><a name="line394"></a> 394     #
</span><span class="inferred1"><a name="line395"></a> 395     #   class Firm &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line396"></a> 396     #     has_many   :clients
</span><span class="inferred1"><a name="line397"></a> 397     #     has_many   :invoices, :through =&gt; :clients
</span><span class="inferred0"><a name="line398"></a> 398     #   end
</span><span class="inferred1"><a name="line399"></a> 399     #
</span><span class="inferred0"><a name="line400"></a> 400     #   class Client &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line401"></a> 401     #     belongs_to :firm
</span><span class="inferred0"><a name="line402"></a> 402     #     has_many   :invoices
</span><span class="inferred1"><a name="line403"></a> 403     #   end
</span><span class="inferred0"><a name="line404"></a> 404     #
</span><span class="inferred1"><a name="line405"></a> 405     #   class Invoice &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line406"></a> 406     #     belongs_to :client
</span><span class="inferred1"><a name="line407"></a> 407     #   end
</span><span class="inferred0"><a name="line408"></a> 408     #
</span><span class="inferred1"><a name="line409"></a> 409     #   @firm = Firm.find :first
</span><span class="inferred0"><a name="line410"></a> 410     #   @firm.clients.collect { |c| c.invoices }.flatten # select all invoices for all clients of the firm
</span><span class="inferred1"><a name="line411"></a> 411     #   @firm.invoices                                   # selects all invoices by going through the Client join model.
</span><span class="inferred0"><a name="line412"></a> 412     #
</span><span class="inferred1"><a name="line413"></a> 413     # === Polymorphic Associations
</span><span class="inferred0"><a name="line414"></a> 414     #
</span><span class="inferred1"><a name="line415"></a> 415     # Polymorphic associations on models are not restricted on what types of models they can be associated with.  Rather, they
</span><span class="inferred0"><a name="line416"></a> 416     # specify an interface that a +has_many+ association must adhere to.
</span><span class="inferred1"><a name="line417"></a> 417     #
</span><span class="inferred0"><a name="line418"></a> 418     #   class Asset &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line419"></a> 419     #     belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred0"><a name="line420"></a> 420     #   end
</span><span class="inferred1"><a name="line421"></a> 421     #
</span><span class="inferred0"><a name="line422"></a> 422     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line423"></a> 423     #     has_many :assets, :as =&gt; :attachable         # The :as option specifies the polymorphic interface to use.
</span><span class="inferred0"><a name="line424"></a> 424     #   end
</span><span class="inferred1"><a name="line425"></a> 425     #
</span><span class="inferred0"><a name="line426"></a> 426     #   @asset.attachable = @post
</span><span class="inferred1"><a name="line427"></a> 427     #
</span><span class="inferred0"><a name="line428"></a> 428     # This works by using a type column in addition to a foreign key to specify the associated record.  In the Asset example, you'd need
</span><span class="inferred1"><a name="line429"></a> 429     # an +attachable_id+ integer column and an +attachable_type+ string column.
</span><span class="inferred0"><a name="line430"></a> 430     #
</span><span class="inferred1"><a name="line431"></a> 431     # Using polymorphic associations in combination with single table inheritance (STI) is a little tricky. In order
</span><span class="inferred0"><a name="line432"></a> 432     # for the associations to work as expected, ensure that you store the base model for the STI models in the
</span><span class="inferred1"><a name="line433"></a> 433     # type column of the polymorphic association. To continue with the asset example above, suppose there are guest posts
</span><span class="inferred0"><a name="line434"></a> 434     # and member posts that use the posts table for STI. In this case, there must be a +type+ column in the posts table.
</span><span class="inferred1"><a name="line435"></a> 435     #
</span><span class="inferred0"><a name="line436"></a> 436     #   class Asset &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line437"></a> 437     #     belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred0"><a name="line438"></a> 438     #
</span><span class="inferred1"><a name="line439"></a> 439     #     def attachable_type=(sType)
</span><span class="inferred0"><a name="line440"></a> 440     #        super(sType.to_s.classify.constantize.base_class.to_s)
</span><span class="inferred1"><a name="line441"></a> 441     #     end
</span><span class="inferred0"><a name="line442"></a> 442     #   end
</span><span class="inferred1"><a name="line443"></a> 443     #
</span><span class="inferred0"><a name="line444"></a> 444     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line445"></a> 445     #     # because we store &quot;Post&quot; in attachable_type now :dependent =&gt; :destroy will work
</span><span class="inferred0"><a name="line446"></a> 446     #     has_many :assets, :as =&gt; :attachable, :dependent =&gt; :destroy
</span><span class="inferred1"><a name="line447"></a> 447     #   end
</span><span class="inferred0"><a name="line448"></a> 448     #
</span><span class="inferred1"><a name="line449"></a> 449     #   class GuestPost &lt; Post
</span><span class="inferred0"><a name="line450"></a> 450     #   end
</span><span class="inferred1"><a name="line451"></a> 451     #
</span><span class="inferred0"><a name="line452"></a> 452     #   class MemberPost &lt; Post
</span><span class="inferred1"><a name="line453"></a> 453     #   end
</span><span class="inferred0"><a name="line454"></a> 454     #
</span><span class="inferred1"><a name="line455"></a> 455     # == Caching
</span><span class="inferred0"><a name="line456"></a> 456     #
</span><span class="inferred1"><a name="line457"></a> 457     # All of the methods are built on a simple caching principle that will keep the result of the last query around unless specifically
</span><span class="inferred0"><a name="line458"></a> 458     # instructed not to. The cache is even shared across methods to make it even cheaper to use the macro-added methods without
</span><span class="inferred1"><a name="line459"></a> 459     # worrying too much about performance at the first go. Example:
</span><span class="inferred0"><a name="line460"></a> 460     #
</span><span class="inferred1"><a name="line461"></a> 461     #   project.milestones             # fetches milestones from the database
</span><span class="inferred0"><a name="line462"></a> 462     #   project.milestones.size        # uses the milestone cache
</span><span class="inferred1"><a name="line463"></a> 463     #   project.milestones.empty?      # uses the milestone cache
</span><span class="inferred0"><a name="line464"></a> 464     #   project.milestones(true).size  # fetches milestones from the database
</span><span class="inferred1"><a name="line465"></a> 465     #   project.milestones             # uses the milestone cache
</span><span class="inferred0"><a name="line466"></a> 466     #
</span><span class="inferred1"><a name="line467"></a> 467     # == Eager loading of associations
</span><span class="inferred0"><a name="line468"></a> 468     #
</span><span class="inferred1"><a name="line469"></a> 469     # Eager loading is a way to find objects of a certain class and a number of named associations. This is
</span><span class="inferred0"><a name="line470"></a> 470     # one of the easiest ways of to prevent the dreaded 1+N problem in which fetching 100 posts that each need to display their author
</span><span class="inferred1"><a name="line471"></a> 471     # triggers 101 database queries. Through the use of eager loading, the 101 queries can be reduced to 2. Example:
</span><span class="inferred0"><a name="line472"></a> 472     #
</span><span class="inferred1"><a name="line473"></a> 473     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line474"></a> 474     #     belongs_to :author
</span><span class="inferred1"><a name="line475"></a> 475     #     has_many   :comments
</span><span class="inferred0"><a name="line476"></a> 476     #   end
</span><span class="inferred1"><a name="line477"></a> 477     #
</span><span class="inferred0"><a name="line478"></a> 478     # Consider the following loop using the class above:
</span><span class="inferred1"><a name="line479"></a> 479     #
</span><span class="inferred0"><a name="line480"></a> 480     #   for post in Post.all
</span><span class="inferred1"><a name="line481"></a> 481     #     puts &quot;Post:            &quot; + post.title
</span><span class="inferred0"><a name="line482"></a> 482     #     puts &quot;Written by:      &quot; + post.author.name
</span><span class="inferred1"><a name="line483"></a> 483     #     puts &quot;Last comment on: &quot; + post.comments.first.created_on
</span><span class="inferred0"><a name="line484"></a> 484     #   end
</span><span class="inferred1"><a name="line485"></a> 485     #
</span><span class="inferred0"><a name="line486"></a> 486     # To iterate over these one hundred posts, we'll generate 201 database queries. Let's first just optimize it for retrieving the author:
</span><span class="inferred1"><a name="line487"></a> 487     #
</span><span class="inferred0"><a name="line488"></a> 488     #   for post in Post.find(:all, :include =&gt; :author)
</span><span class="inferred1"><a name="line489"></a> 489     #
</span><span class="inferred0"><a name="line490"></a> 490     # This references the name of the +belongs_to+ association that also used the &lt;tt&gt;:author&lt;/tt&gt; symbol. After loading the posts, find
</span><span class="inferred1"><a name="line491"></a> 491     # will collect the +author_id+ from each one and load all the referenced authors with one query. Doing so will cut down the number of queries from 201 to 102.
</span><span class="inferred0"><a name="line492"></a> 492     #
</span><span class="inferred1"><a name="line493"></a> 493     # We can improve upon the situation further by referencing both associations in the finder with:
</span><span class="inferred0"><a name="line494"></a> 494     #
</span><span class="inferred1"><a name="line495"></a> 495     #   for post in Post.find(:all, :include =&gt; [ :author, :comments ])
</span><span class="inferred0"><a name="line496"></a> 496     #
</span><span class="inferred1"><a name="line497"></a> 497     # This will load all comments with a single query. This reduces the total number of queries to 3. More generally the number of queries
</span><span class="inferred0"><a name="line498"></a> 498     # will be 1 plus the number of associations named (except if some of the associations are polymorphic +belongs_to+ - see below).
</span><span class="inferred1"><a name="line499"></a> 499     #
</span><span class="inferred0"><a name="line500"></a> 500     # To include a deep hierarchy of associations, use a hash:
</span><span class="inferred1"><a name="line501"></a> 501     #
</span><span class="inferred0"><a name="line502"></a> 502     #   for post in Post.find(:all, :include =&gt; [ :author, { :comments =&gt; { :author =&gt; :gravatar } } ])
</span><span class="inferred1"><a name="line503"></a> 503     #
</span><span class="inferred0"><a name="line504"></a> 504     # That'll grab not only all the comments but all their authors and gravatar pictures.  You can mix and match
</span><span class="inferred1"><a name="line505"></a> 505     # symbols, arrays and hashes in any combination to describe the associations you want to load.
</span><span class="inferred0"><a name="line506"></a> 506     #
</span><span class="inferred1"><a name="line507"></a> 507     # All of this power shouldn't fool you into thinking that you can pull out huge amounts of data with no performance penalty just because you've reduced
</span><span class="inferred0"><a name="line508"></a> 508     # the number of queries. The database still needs to send all the data to Active Record and it still needs to be processed. So it's no
</span><span class="inferred1"><a name="line509"></a> 509     # catch-all for performance problems, but it's a great way to cut down on the number of queries in a situation as the one described above.
</span><span class="inferred0"><a name="line510"></a> 510     #
</span><span class="inferred1"><a name="line511"></a> 511     # Since only one table is loaded at a time, conditions or orders cannot reference tables other than the main one. If this is the case
</span><span class="inferred0"><a name="line512"></a> 512     # Active Record falls back to the previously used LEFT OUTER JOIN based strategy. For example
</span><span class="inferred1"><a name="line513"></a> 513     #  
</span><span class="inferred0"><a name="line514"></a> 514     #   Post.find(:all, :include =&gt; [ :author, :comments ], :conditions =&gt; ['comments.approved = ?', true])
</span><span class="inferred1"><a name="line515"></a> 515     #
</span><span class="inferred0"><a name="line516"></a> 516     # will result in a single SQL query with joins along the lines of: &lt;tt&gt;LEFT OUTER JOIN comments ON comments.post_id = posts.id&lt;/tt&gt; and
</span><span class="inferred1"><a name="line517"></a> 517     # &lt;tt&gt;LEFT OUTER JOIN authors ON authors.id = posts.author_id&lt;/tt&gt;. Note that using conditions like this can have unintended consequences.
</span><span class="inferred0"><a name="line518"></a> 518     # In the above example posts with no approved comments are not returned at all, because the conditions apply to the SQL statement as a whole
</span><span class="inferred1"><a name="line519"></a> 519     # and not just to the association. You must disambiguate column references for this fallback to happen, for example
</span><span class="inferred0"><a name="line520"></a> 520     # &lt;tt&gt;:order =&gt; &quot;author.name DESC&quot;&lt;/tt&gt; will work but &lt;tt&gt;:order =&gt; &quot;name DESC&quot;&lt;/tt&gt; will not. 
</span><span class="inferred1"><a name="line521"></a> 521     #
</span><span class="inferred0"><a name="line522"></a> 522     # If you do want eagerload only some members of an association it is usually more natural to &lt;tt&gt;:include&lt;/tt&gt; an association
</span><span class="inferred1"><a name="line523"></a> 523     # which has conditions defined on it:
</span><span class="inferred0"><a name="line524"></a> 524     #
</span><span class="inferred1"><a name="line525"></a> 525     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line526"></a> 526     #     has_many :approved_comments, :class_name =&gt; 'Comment', :conditions =&gt; ['approved = ?', true]
</span><span class="inferred1"><a name="line527"></a> 527     #   end
</span><span class="inferred0"><a name="line528"></a> 528     #
</span><span class="inferred1"><a name="line529"></a> 529     #   Post.find(:all, :include =&gt; :approved_comments)
</span><span class="inferred0"><a name="line530"></a> 530     #
</span><span class="inferred1"><a name="line531"></a> 531     # will load posts and eager load the +approved_comments+ association, which contains only those comments that have been approved.
</span><span class="inferred0"><a name="line532"></a> 532     #
</span><span class="inferred1"><a name="line533"></a> 533     # If you eager load an association with a specified &lt;tt&gt;:limit&lt;/tt&gt; option, it will be ignored, returning all the associated objects:
</span><span class="inferred0"><a name="line534"></a> 534     #
</span><span class="inferred1"><a name="line535"></a> 535     #   class Picture &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line536"></a> 536     #     has_many :most_recent_comments, :class_name =&gt; 'Comment', :order =&gt; 'id DESC', :limit =&gt; 10
</span><span class="inferred1"><a name="line537"></a> 537     #   end
</span><span class="inferred0"><a name="line538"></a> 538     #
</span><span class="inferred1"><a name="line539"></a> 539     #   Picture.find(:first, :include =&gt; :most_recent_comments).most_recent_comments # =&gt; returns all associated comments.
</span><span class="inferred0"><a name="line540"></a> 540     #
</span><span class="inferred1"><a name="line541"></a> 541     # When eager loaded, conditions are interpolated in the context of the model class, not the model instance.  Conditions are lazily interpolated
</span><span class="inferred0"><a name="line542"></a> 542     # before the actual model exists.
</span><span class="inferred1"><a name="line543"></a> 543     #
</span><span class="inferred0"><a name="line544"></a> 544     # Eager loading is supported with polymorphic associations.
</span><span class="inferred1"><a name="line545"></a> 545     #
</span><span class="inferred0"><a name="line546"></a> 546     #   class Address &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line547"></a> 547     #     belongs_to :addressable, :polymorphic =&gt; true
</span><span class="inferred0"><a name="line548"></a> 548     #   end
</span><span class="inferred1"><a name="line549"></a> 549     #
</span><span class="inferred0"><a name="line550"></a> 550     # A call that tries to eager load the addressable model
</span><span class="inferred1"><a name="line551"></a> 551     #
</span><span class="inferred0"><a name="line552"></a> 552     #   Address.find(:all, :include =&gt; :addressable)
</span><span class="inferred1"><a name="line553"></a> 553     #
</span><span class="inferred0"><a name="line554"></a> 554     # will execute one query to load the addresses and load the addressables with one query per addressable type. 
</span><span class="inferred1"><a name="line555"></a> 555     # For example if all the addressables are either of class Person or Company then a total of 3 queries will be executed. The list of
</span><span class="inferred0"><a name="line556"></a> 556     # addressable types to load is determined on the back of the addresses loaded. This is not supported if Active Record has to fallback
</span><span class="inferred1"><a name="line557"></a> 557     # to the previous implementation of eager loading and will raise ActiveRecord::EagerLoadPolymorphicError. The reason is that the parent 
</span><span class="inferred0"><a name="line558"></a> 558     # model's type is a column value so its corresponding table name cannot be put in the +FROM+/+JOIN+ clauses of that query.
</span><span class="inferred1"><a name="line559"></a> 559     #
</span><span class="inferred0"><a name="line560"></a> 560     # == Table Aliasing
</span><span class="inferred1"><a name="line561"></a> 561     #
</span><span class="inferred0"><a name="line562"></a> 562     # Active Record uses table aliasing in the case that a table is referenced multiple times in a join.  If a table is referenced only once,
</span><span class="inferred1"><a name="line563"></a> 563     # the standard table name is used.  The second time, the table is aliased as &lt;tt&gt;#{reflection_name}_#{parent_table_name}&lt;/tt&gt;.  Indexes are appended
</span><span class="inferred0"><a name="line564"></a> 564     # for any more successive uses of the table name.
</span><span class="inferred1"><a name="line565"></a> 565     #
</span><span class="inferred0"><a name="line566"></a> 566     #   Post.find :all, :joins =&gt; :comments
</span><span class="inferred1"><a name="line567"></a> 567     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ...
</span><span class="inferred0"><a name="line568"></a> 568     #   Post.find :all, :joins =&gt; :special_comments # STI
</span><span class="inferred1"><a name="line569"></a> 569     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ... AND comments.type = 'SpecialComment'
</span><span class="inferred0"><a name="line570"></a> 570     #   Post.find :all, :joins =&gt; [:comments, :special_comments] # special_comments is the reflection name, posts is the parent table name
</span><span class="inferred1"><a name="line571"></a> 571     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ... INNER JOIN comments special_comments_posts
</span><span class="inferred0"><a name="line572"></a> 572     #
</span><span class="inferred1"><a name="line573"></a> 573     # Acts as tree example:
</span><span class="inferred0"><a name="line574"></a> 574     #
</span><span class="inferred1"><a name="line575"></a> 575     #   TreeMixin.find :all, :joins =&gt; :children
</span><span class="inferred0"><a name="line576"></a> 576     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred1"><a name="line577"></a> 577     #   TreeMixin.find :all, :joins =&gt; {:children =&gt; :parent}
</span><span class="inferred0"><a name="line578"></a> 578     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred1"><a name="line579"></a> 579     #                               INNER JOIN parents_mixins ...
</span><span class="inferred0"><a name="line580"></a> 580     #   TreeMixin.find :all, :joins =&gt; {:children =&gt; {:parent =&gt; :children}}
</span><span class="inferred1"><a name="line581"></a> 581     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred0"><a name="line582"></a> 582     #                               INNER JOIN parents_mixins ...
</span><span class="inferred1"><a name="line583"></a> 583     #                               INNER JOIN mixins childrens_mixins_2
</span><span class="inferred0"><a name="line584"></a> 584     #
</span><span class="inferred1"><a name="line585"></a> 585     # Has and Belongs to Many join tables use the same idea, but add a &lt;tt&gt;_join&lt;/tt&gt; suffix:
</span><span class="inferred0"><a name="line586"></a> 586     #
</span><span class="inferred1"><a name="line587"></a> 587     #   Post.find :all, :joins =&gt; :categories
</span><span class="inferred0"><a name="line588"></a> 588     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred1"><a name="line589"></a> 589     #   Post.find :all, :joins =&gt; {:categories =&gt; :posts}
</span><span class="inferred0"><a name="line590"></a> 590     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred1"><a name="line591"></a> 591     #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
</span><span class="inferred0"><a name="line592"></a> 592     #   Post.find :all, :joins =&gt; {:categories =&gt; {:posts =&gt; :categories}}
</span><span class="inferred1"><a name="line593"></a> 593     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred0"><a name="line594"></a> 594     #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
</span><span class="inferred1"><a name="line595"></a> 595     #                              INNER JOIN categories_posts categories_posts_join INNER JOIN categories categories_posts_2
</span><span class="inferred0"><a name="line596"></a> 596     #
</span><span class="inferred1"><a name="line597"></a> 597     # If you wish to specify your own custom joins using a &lt;tt&gt;:joins&lt;/tt&gt; option, those table names will take precedence over the eager associations:
</span><span class="inferred0"><a name="line598"></a> 598     #
</span><span class="inferred1"><a name="line599"></a> 599     #   Post.find :all, :joins =&gt; :comments, :joins =&gt; &quot;inner join comments ...&quot;
</span><span class="inferred0"><a name="line600"></a> 600     #   # =&gt; SELECT ... FROM posts INNER JOIN comments_posts ON ... INNER JOIN comments ...
</span><span class="inferred1"><a name="line601"></a> 601     #   Post.find :all, :joins =&gt; [:comments, :special_comments], :joins =&gt; &quot;inner join comments ...&quot;
</span><span class="inferred0"><a name="line602"></a> 602     #   # =&gt; SELECT ... FROM posts INNER JOIN comments comments_posts ON ...
</span><span class="inferred1"><a name="line603"></a> 603     #                              INNER JOIN comments special_comments_posts ...
</span><span class="inferred0"><a name="line604"></a> 604     #                              INNER JOIN comments ...
</span><span class="inferred1"><a name="line605"></a> 605     #
</span><span class="inferred0"><a name="line606"></a> 606     # Table aliases are automatically truncated according to the maximum length of table identifiers according to the specific database.
</span><span class="inferred1"><a name="line607"></a> 607     #
</span><span class="inferred0"><a name="line608"></a> 608     # == Modules
</span><span class="inferred1"><a name="line609"></a> 609     #
</span><span class="inferred0"><a name="line610"></a> 610     # By default, associations will look for objects within the current module scope. Consider:
</span><span class="inferred1"><a name="line611"></a> 611     #
</span><span class="inferred0"><a name="line612"></a> 612     #   module MyApplication
</span><span class="inferred1"><a name="line613"></a> 613     #     module Business
</span><span class="inferred0"><a name="line614"></a> 614     #       class Firm &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line615"></a> 615     #          has_many :clients
</span><span class="inferred0"><a name="line616"></a> 616     #        end
</span><span class="inferred1"><a name="line617"></a> 617     #
</span><span class="inferred0"><a name="line618"></a> 618     #       class Client &lt; ActiveRecord::Base; end
</span><span class="inferred1"><a name="line619"></a> 619     #     end
</span><span class="inferred0"><a name="line620"></a> 620     #   end
</span><span class="inferred1"><a name="line621"></a> 621     #
</span><span class="inferred0"><a name="line622"></a> 622     # When &lt;tt&gt;Firm#clients&lt;/tt&gt; is called, it will in turn call &lt;tt&gt;MyApplication::Business::Client.find_all_by_firm_id(firm.id)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line623"></a> 623     # If you want to associate with a class in another module scope, this can be done by specifying the complete class name.
</span><span class="inferred0"><a name="line624"></a> 624     # Example:
</span><span class="inferred1"><a name="line625"></a> 625     #
</span><span class="inferred0"><a name="line626"></a> 626     #   module MyApplication
</span><span class="inferred1"><a name="line627"></a> 627     #     module Business
</span><span class="inferred0"><a name="line628"></a> 628     #       class Firm &lt; ActiveRecord::Base; end
</span><span class="inferred1"><a name="line629"></a> 629     #     end
</span><span class="inferred0"><a name="line630"></a> 630     #
</span><span class="inferred1"><a name="line631"></a> 631     #     module Billing
</span><span class="inferred0"><a name="line632"></a> 632     #       class Account &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line633"></a> 633     #         belongs_to :firm, :class_name =&gt; &quot;MyApplication::Business::Firm&quot;
</span><span class="inferred0"><a name="line634"></a> 634     #       end
</span><span class="inferred1"><a name="line635"></a> 635     #     end
</span><span class="inferred0"><a name="line636"></a> 636     #   end
</span><span class="inferred1"><a name="line637"></a> 637     #
</span><span class="inferred0"><a name="line638"></a> 638     # == Type safety with &lt;tt&gt;ActiveRecord::AssociationTypeMismatch&lt;/tt&gt;
</span><span class="inferred1"><a name="line639"></a> 639     #
</span><span class="inferred0"><a name="line640"></a> 640     # If you attempt to assign an object to an association that doesn't match the inferred or specified &lt;tt&gt;:class_name&lt;/tt&gt;, you'll
</span><span class="inferred1"><a name="line641"></a> 641     # get an &lt;tt&gt;ActiveRecord::AssociationTypeMismatch&lt;/tt&gt;.
</span><span class="inferred0"><a name="line642"></a> 642     #
</span><span class="inferred1"><a name="line643"></a> 643     # == Options
</span><span class="inferred0"><a name="line644"></a> 644     #
</span><span class="inferred1"><a name="line645"></a> 645     # All of the association macros can be specialized through options. This makes cases more complex than the simple and guessable ones
</span><span class="inferred0"><a name="line646"></a> 646     # possible.
</span><span class="marked1"><a name="line647"></a> 647     module ClassMethods
</span><span class="inferred0"><a name="line648"></a> 648       # Specifies a one-to-many association. The following methods for retrieval and query of
</span><span class="inferred1"><a name="line649"></a> 649       # collections of associated objects will be added:
</span><span class="inferred0"><a name="line650"></a> 650       #
</span><span class="inferred1"><a name="line651"></a> 651       # [collection(force_reload = false)]
</span><span class="inferred0"><a name="line652"></a> 652       #   Returns an array of all the associated objects.
</span><span class="inferred1"><a name="line653"></a> 653       #   An empty array is returned if none are found.
</span><span class="inferred0"><a name="line654"></a> 654       # [collection&lt;&lt;(object, ...)]
</span><span class="inferred1"><a name="line655"></a> 655       #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
</span><span class="inferred0"><a name="line656"></a> 656       # [collection.delete(object, ...)]
</span><span class="inferred1"><a name="line657"></a> 657       #   Removes one or more objects from the collection by setting their foreign keys to +NULL+.
</span><span class="inferred0"><a name="line658"></a> 658       #   Objects will be in addition destroyed if they're associated with &lt;tt&gt;:dependent =&gt; :destroy&lt;/tt&gt;,
</span><span class="inferred1"><a name="line659"></a> 659       #   and deleted if they're associated with &lt;tt&gt;:dependent =&gt; :delete_all&lt;/tt&gt;.
</span><span class="inferred0"><a name="line660"></a> 660       # [collection=objects]
</span><span class="inferred1"><a name="line661"></a> 661       #   Replaces the collections content by deleting and adding objects as appropriate.
</span><span class="inferred0"><a name="line662"></a> 662       # [collection_singular_ids]
</span><span class="inferred1"><a name="line663"></a> 663       #   Returns an array of the associated objects' ids
</span><span class="inferred0"><a name="line664"></a> 664       # [collection_singular_ids=ids]
</span><span class="inferred1"><a name="line665"></a> 665       #   Replace the collection with the objects identified by the primary keys in +ids+
</span><span class="inferred0"><a name="line666"></a> 666       # [collection.clear]
</span><span class="inferred1"><a name="line667"></a> 667       #   Removes every object from the collection. This destroys the associated objects if they
</span><span class="inferred0"><a name="line668"></a> 668       #   are associated with &lt;tt&gt;:dependent =&gt; :destroy&lt;/tt&gt;, deletes them directly from the
</span><span class="inferred1"><a name="line669"></a> 669       #   database if &lt;tt&gt;:dependent =&gt; :delete_all&lt;/tt&gt;, otherwise sets their foreign keys to +NULL+.
</span><span class="inferred0"><a name="line670"></a> 670       # [collection.empty?]
</span><span class="inferred1"><a name="line671"></a> 671       #   Returns +true+ if there are no associated objects.
</span><span class="inferred0"><a name="line672"></a> 672       # [collection.size]
</span><span class="inferred1"><a name="line673"></a> 673       #   Returns the number of associated objects.
</span><span class="inferred0"><a name="line674"></a> 674       # [collection.find(...)]
</span><span class="inferred1"><a name="line675"></a> 675       #   Finds an associated object according to the same rules as ActiveRecord::Base.find.
</span><span class="inferred0"><a name="line676"></a> 676       # [collection.exists?(...)]
</span><span class="inferred1"><a name="line677"></a> 677       #   Checks whether an associated object with the given conditions exists.
</span><span class="inferred0"><a name="line678"></a> 678       #   Uses the same rules as ActiveRecord::Base.exists?.
</span><span class="inferred1"><a name="line679"></a> 679       # [collection.build(attributes = {}, ...)]
</span><span class="inferred0"><a name="line680"></a> 680       #   Returns one or more new objects of the collection type that have been instantiated
</span><span class="inferred1"><a name="line681"></a> 681       #   with +attributes+ and linked to this object through a foreign key, but have not yet
</span><span class="inferred0"><a name="line682"></a> 682       #   been saved. &lt;b&gt;Note:&lt;/b&gt; This only works if an associated object already exists, not if
</span><span class="inferred1"><a name="line683"></a> 683       #   it's +nil+!
</span><span class="inferred0"><a name="line684"></a> 684       # [collection.create(attributes = {})]
</span><span class="inferred1"><a name="line685"></a> 685       #   Returns a new object of the collection type that has been instantiated
</span><span class="inferred0"><a name="line686"></a> 686       #   with +attributes+, linked to this object through a foreign key, and that has already
</span><span class="inferred1"><a name="line687"></a> 687       #   been saved (if it passed the validation). &lt;b&gt;Note:&lt;/b&gt; This only works if an associated
</span><span class="inferred0"><a name="line688"></a> 688       #   object already exists, not if it's +nil+!
</span><span class="inferred1"><a name="line689"></a> 689       #
</span><span class="inferred0"><a name="line690"></a> 690       # (*Note*: +collection+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred1"><a name="line691"></a> 691       # &lt;tt&gt;has_many :clients&lt;/tt&gt; would add among others &lt;tt&gt;clients.empty?&lt;/tt&gt;.)
</span><span class="inferred0"><a name="line692"></a> 692       #
</span><span class="inferred1"><a name="line693"></a> 693       # === Example
</span><span class="inferred0"><a name="line694"></a> 694       #
</span><span class="inferred1"><a name="line695"></a> 695       # Example: A Firm class declares &lt;tt&gt;has_many :clients&lt;/tt&gt;, which will add:
</span><span class="inferred0"><a name="line696"></a> 696       # * &lt;tt&gt;Firm#clients&lt;/tt&gt; (similar to &lt;tt&gt;Clients.find :all, :conditions =&gt; [&quot;firm_id = ?&quot;, id]&lt;/tt&gt;)
</span><span class="inferred1"><a name="line697"></a> 697       # * &lt;tt&gt;Firm#clients&lt;&lt;&lt;/tt&gt;
</span><span class="inferred0"><a name="line698"></a> 698       # * &lt;tt&gt;Firm#clients.delete&lt;/tt&gt;
</span><span class="inferred1"><a name="line699"></a> 699       # * &lt;tt&gt;Firm#clients=&lt;/tt&gt;
</span><span class="inferred0"><a name="line700"></a> 700       # * &lt;tt&gt;Firm#client_ids&lt;/tt&gt;
</span><span class="inferred1"><a name="line701"></a> 701       # * &lt;tt&gt;Firm#client_ids=&lt;/tt&gt;
</span><span class="inferred0"><a name="line702"></a> 702       # * &lt;tt&gt;Firm#clients.clear&lt;/tt&gt;
</span><span class="inferred1"><a name="line703"></a> 703       # * &lt;tt&gt;Firm#clients.empty?&lt;/tt&gt; (similar to &lt;tt&gt;firm.clients.size == 0&lt;/tt&gt;)
</span><span class="inferred0"><a name="line704"></a> 704       # * &lt;tt&gt;Firm#clients.size&lt;/tt&gt; (similar to &lt;tt&gt;Client.count &quot;firm_id = #{id}&quot;&lt;/tt&gt;)
</span><span class="inferred1"><a name="line705"></a> 705       # * &lt;tt&gt;Firm#clients.find&lt;/tt&gt; (similar to &lt;tt&gt;Client.find(id, :conditions =&gt; &quot;firm_id = #{id}&quot;)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line706"></a> 706       # * &lt;tt&gt;Firm#clients.exists?(:name =&gt; 'ACME')&lt;/tt&gt; (similar to &lt;tt&gt;Client.exists?(:name =&gt; 'ACME', :firm_id =&gt; firm.id)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line707"></a> 707       # * &lt;tt&gt;Firm#clients.build&lt;/tt&gt; (similar to &lt;tt&gt;Client.new(&quot;firm_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line708"></a> 708       # * &lt;tt&gt;Firm#clients.create&lt;/tt&gt; (similar to &lt;tt&gt;c = Client.new(&quot;firm_id&quot; =&gt; id); c.save; c&lt;/tt&gt;)
</span><span class="inferred1"><a name="line709"></a> 709       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred0"><a name="line710"></a> 710       #
</span><span class="inferred1"><a name="line711"></a> 711       # === Supported options
</span><span class="inferred0"><a name="line712"></a> 712       # [:class_name]
</span><span class="inferred1"><a name="line713"></a> 713       #   Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred0"><a name="line714"></a> 714       #   from the association name. So &lt;tt&gt;has_many :products&lt;/tt&gt; will by default be linked to the Product class, but
</span><span class="inferred1"><a name="line715"></a> 715       #   if the real class name is SpecialProduct, you'll have to specify it with this option.
</span><span class="inferred0"><a name="line716"></a> 716       # [:conditions]
</span><span class="inferred1"><a name="line717"></a> 717       #   Specify the conditions that the associated objects must meet in order to be included as a +WHERE+
</span><span class="inferred0"><a name="line718"></a> 718       #   SQL fragment, such as &lt;tt&gt;price &gt; 5 AND name LIKE 'B%'&lt;/tt&gt;.  Record creations from the association are scoped if a hash
</span><span class="inferred1"><a name="line719"></a> 719       #   is used.  &lt;tt&gt;has_many :posts, :conditions =&gt; {:published =&gt; true}&lt;/tt&gt; will create published posts with &lt;tt&gt;@blog.posts.create&lt;/tt&gt;
</span><span class="inferred0"><a name="line720"></a> 720       #   or &lt;tt&gt;@blog.posts.build&lt;/tt&gt;.
</span><span class="inferred1"><a name="line721"></a> 721       # [:order]
</span><span class="inferred0"><a name="line722"></a> 722       #   Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred1"><a name="line723"></a> 723       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;.
</span><span class="inferred0"><a name="line724"></a> 724       # [:foreign_key]
</span><span class="inferred1"><a name="line725"></a> 725       #   Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred0"><a name="line726"></a> 726       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_many+ association will use &quot;person_id&quot;
</span><span class="inferred1"><a name="line727"></a> 727       #   as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred0"><a name="line728"></a> 728       # [:primary_key]
</span><span class="inferred1"><a name="line729"></a> 729       #   Specify the method that returns the primary key used for the association. By default this is +id+.
</span><span class="inferred0"><a name="line730"></a> 730       # [:dependent]
</span><span class="inferred1"><a name="line731"></a> 731       #   If set to &lt;tt&gt;:destroy&lt;/tt&gt; all the associated objects are destroyed
</span><span class="inferred0"><a name="line732"></a> 732       #   alongside this object by calling their +destroy+ method.  If set to &lt;tt&gt;:delete_all&lt;/tt&gt; all associated
</span><span class="inferred1"><a name="line733"></a> 733       #   objects are deleted *without* calling their +destroy+ method.  If set to &lt;tt&gt;:nullify&lt;/tt&gt; all associated
</span><span class="inferred0"><a name="line734"></a> 734       #   objects' foreign keys are set to +NULL+ *without* calling their +save+ callbacks. *Warning:* This option is ignored when also using
</span><span class="inferred1"><a name="line735"></a> 735       #   the &lt;tt&gt;:through&lt;/tt&gt; option.
</span><span class="inferred0"><a name="line736"></a> 736       # [:finder_sql]
</span><span class="inferred1"><a name="line737"></a> 737       #   Specify a complete SQL statement to fetch the association. This is a good way to go for complex
</span><span class="inferred0"><a name="line738"></a> 738       #   associations that depend on multiple tables. Note: When this option is used, +find_in_collection+ is _not_ added.
</span><span class="inferred1"><a name="line739"></a> 739       # [:counter_sql]
</span><span class="inferred0"><a name="line740"></a> 740       #   Specify a complete SQL statement to fetch the size of the association. If &lt;tt&gt;:finder_sql&lt;/tt&gt; is
</span><span class="inferred1"><a name="line741"></a> 741       #   specified but not &lt;tt&gt;:counter_sql&lt;/tt&gt;, &lt;tt&gt;:counter_sql&lt;/tt&gt; will be generated by replacing &lt;tt&gt;SELECT ... FROM&lt;/tt&gt; with &lt;tt&gt;SELECT COUNT(*) FROM&lt;/tt&gt;.
</span><span class="inferred0"><a name="line742"></a> 742       # [:extend]
</span><span class="inferred1"><a name="line743"></a> 743       #   Specify a named module for extending the proxy. See &quot;Association extensions&quot;.
</span><span class="inferred0"><a name="line744"></a> 744       # [:include]
</span><span class="inferred1"><a name="line745"></a> 745       #   Specify second-order associations that should be eager loaded when the collection is loaded.
</span><span class="inferred0"><a name="line746"></a> 746       # [:group]
</span><span class="inferred1"><a name="line747"></a> 747       #   An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred0"><a name="line748"></a> 748       # [:having]
</span><span class="inferred1"><a name="line749"></a> 749       #   Combined with +:group+ this can be used to filter the records that a &lt;tt&gt;GROUP BY&lt;/tt&gt; returns. Uses the &lt;tt&gt;HAVING&lt;/tt&gt; SQL-clause.
</span><span class="inferred0"><a name="line750"></a> 750       # [:limit]
</span><span class="inferred1"><a name="line751"></a> 751       #   An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred0"><a name="line752"></a> 752       # [:offset]
</span><span class="inferred1"><a name="line753"></a> 753       #   An integer determining the offset from where the rows should be fetched. So at 5, it would skip the first 4 rows.
</span><span class="inferred0"><a name="line754"></a> 754       # [:select]
</span><span class="inferred1"><a name="line755"></a> 755       #   By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if you, for example, want to do a join
</span><span class="inferred0"><a name="line756"></a> 756       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred1"><a name="line757"></a> 757       # [:as]
</span><span class="inferred0"><a name="line758"></a> 758       #   Specifies a polymorphic interface (See &lt;tt&gt;belongs_to&lt;/tt&gt;).
</span><span class="inferred1"><a name="line759"></a> 759       # [:through]
</span><span class="inferred0"><a name="line760"></a> 760       #   Specifies a Join Model through which to perform the query.  Options for &lt;tt&gt;:class_name&lt;/tt&gt; and &lt;tt&gt;:foreign_key&lt;/tt&gt;
</span><span class="inferred1"><a name="line761"></a> 761       #   are ignored, as the association uses the source reflection. You can only use a &lt;tt&gt;:through&lt;/tt&gt; query through a &lt;tt&gt;belongs_to&lt;/tt&gt;
</span><span class="inferred0"><a name="line762"></a> 762       #   or &lt;tt&gt;has_many&lt;/tt&gt; association on the join model.
</span><span class="inferred1"><a name="line763"></a> 763       # [:source]
</span><span class="inferred0"><a name="line764"></a> 764       #   Specifies the source association name used by &lt;tt&gt;has_many :through&lt;/tt&gt; queries.  Only use it if the name cannot be
</span><span class="inferred1"><a name="line765"></a> 765       #   inferred from the association.  &lt;tt&gt;has_many :subscribers, :through =&gt; :subscriptions&lt;/tt&gt; will look for either &lt;tt&gt;:subscribers&lt;/tt&gt; or
</span><span class="inferred0"><a name="line766"></a> 766       #   &lt;tt&gt;:subscriber&lt;/tt&gt; on Subscription, unless a &lt;tt&gt;:source&lt;/tt&gt; is given.
</span><span class="inferred1"><a name="line767"></a> 767       # [:source_type]
</span><span class="inferred0"><a name="line768"></a> 768       #   Specifies type of the source association used by &lt;tt&gt;has_many :through&lt;/tt&gt; queries where the source
</span><span class="inferred1"><a name="line769"></a> 769       #   association is a polymorphic +belongs_to+.
</span><span class="inferred0"><a name="line770"></a> 770       # [:uniq]
</span><span class="inferred1"><a name="line771"></a> 771       #   If true, duplicates will be omitted from the collection. Useful in conjunction with &lt;tt&gt;:through&lt;/tt&gt;.
</span><span class="inferred0"><a name="line772"></a> 772       # [:readonly]
</span><span class="inferred1"><a name="line773"></a> 773       #   If true, all the associated objects are readonly through the association.
</span><span class="inferred0"><a name="line774"></a> 774       # [:validate]
</span><span class="inferred1"><a name="line775"></a> 775       #   If false, don't validate the associated objects when saving the parent object. true by default.
</span><span class="inferred0"><a name="line776"></a> 776       # [:autosave]
</span><span class="inferred1"><a name="line777"></a> 777       #   If true, always save any loaded members and destroy members marked for destruction, when saving the parent object. Off by default.
</span><span class="inferred0"><a name="line778"></a> 778       #
</span><span class="inferred1"><a name="line779"></a> 779       # Option examples:
</span><span class="inferred0"><a name="line780"></a> 780       #   has_many :comments, :order =&gt; &quot;posted_on&quot;
</span><span class="inferred1"><a name="line781"></a> 781       #   has_many :comments, :include =&gt; :author
</span><span class="inferred0"><a name="line782"></a> 782       #   has_many :people, :class_name =&gt; &quot;Person&quot;, :conditions =&gt; &quot;deleted = 0&quot;, :order =&gt; &quot;name&quot;
</span><span class="inferred1"><a name="line783"></a> 783       #   has_many :tracks, :order =&gt; &quot;position&quot;, :dependent =&gt; :destroy
</span><span class="inferred0"><a name="line784"></a> 784       #   has_many :comments, :dependent =&gt; :nullify
</span><span class="inferred1"><a name="line785"></a> 785       #   has_many :tags, :as =&gt; :taggable
</span><span class="inferred0"><a name="line786"></a> 786       #   has_many :reports, :readonly =&gt; true
</span><span class="inferred1"><a name="line787"></a> 787       #   has_many :subscribers, :through =&gt; :subscriptions, :source =&gt; :user
</span><span class="inferred0"><a name="line788"></a> 788       #   has_many :subscribers, :class_name =&gt; &quot;Person&quot;, :finder_sql =&gt;
</span><span class="inferred1"><a name="line789"></a> 789       #       'SELECT DISTINCT people.* ' +
</span><span class="inferred0"><a name="line790"></a> 790       #       'FROM people p, post_subscriptions ps ' +
</span><span class="inferred1"><a name="line791"></a> 791       #       'WHERE ps.post_id = #{id} AND ps.person_id = p.id ' +
</span><span class="inferred0"><a name="line792"></a> 792       #       'ORDER BY p.first_name'
</span><span class="marked1"><a name="line793"></a> 793       def has_many(association_id, options = {}, &amp;extension)
</span><span class="marked0"><a name="line794"></a> 794         reflection = create_has_many_reflection(association_id, options, &amp;extension)
</span><span class="marked1"><a name="line795"></a> 795         configure_dependency_for_has_many(reflection)
</span><span class="marked0"><a name="line796"></a> 796         add_association_callbacks(reflection.name, reflection.options)
</span><span class="inferred1"><a name="line797"></a> 797 
</span><span class="marked0"><a name="line798"></a> 798         if options[:through]
</span><span class="marked1"><a name="line799"></a> 799           collection_accessor_methods(reflection, HasManyThroughAssociation)
</span><span class="inferred0"><a name="line800"></a> 800         else
</span><span class="marked1"><a name="line801"></a> 801           collection_accessor_methods(reflection, HasManyAssociation)
</span><span class="inferred0"><a name="line802"></a> 802         end
</span><span class="inferred1"><a name="line803"></a> 803       end
</span><span class="inferred0"><a name="line804"></a> 804 
</span><span class="inferred1"><a name="line805"></a> 805       # Specifies a one-to-one association with another class. This method should only be used
</span><span class="inferred0"><a name="line806"></a> 806       # if the other class contains the foreign key. If the current class contains the foreign key,
</span><span class="inferred1"><a name="line807"></a> 807       # then you should use +belongs_to+ instead. See also ActiveRecord::Associations::ClassMethods's overview
</span><span class="inferred0"><a name="line808"></a> 808       # on when to use has_one and when to use belongs_to.
</span><span class="inferred1"><a name="line809"></a> 809       #
</span><span class="inferred0"><a name="line810"></a> 810       # The following methods for retrieval and query of a single associated object will be added:
</span><span class="inferred1"><a name="line811"></a> 811       #
</span><span class="inferred0"><a name="line812"></a> 812       # [association(force_reload = false)]
</span><span class="inferred1"><a name="line813"></a> 813       #   Returns the associated object. +nil+ is returned if none is found.
</span><span class="inferred0"><a name="line814"></a> 814       # [association=(associate)]
</span><span class="inferred1"><a name="line815"></a> 815       #   Assigns the associate object, extracts the primary key, sets it as the foreign key,
</span><span class="inferred0"><a name="line816"></a> 816       #   and saves the associate object.
</span><span class="inferred1"><a name="line817"></a> 817       # [build_association(attributes = {})]
</span><span class="inferred0"><a name="line818"></a> 818       #   Returns a new object of the associated type that has been instantiated
</span><span class="inferred1"><a name="line819"></a> 819       #   with +attributes+ and linked to this object through a foreign key, but has not
</span><span class="inferred0"><a name="line820"></a> 820       #   yet been saved. &lt;b&gt;Note:&lt;/b&gt; This ONLY works if an association already exists.
</span><span class="inferred1"><a name="line821"></a> 821       #   It will NOT work if the association is +nil+.
</span><span class="inferred0"><a name="line822"></a> 822       # [create_association(attributes = {})]
</span><span class="inferred1"><a name="line823"></a> 823       #   Returns a new object of the associated type that has been instantiated
</span><span class="inferred0"><a name="line824"></a> 824       #   with +attributes+, linked to this object through a foreign key, and that
</span><span class="inferred1"><a name="line825"></a> 825       #   has already been saved (if it passed the validation).
</span><span class="inferred0"><a name="line826"></a> 826       #
</span><span class="inferred1"><a name="line827"></a> 827       # (+association+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred0"><a name="line828"></a> 828       # &lt;tt&gt;has_one :manager&lt;/tt&gt; would add among others &lt;tt&gt;manager.nil?&lt;/tt&gt;.)
</span><span class="inferred1"><a name="line829"></a> 829       #
</span><span class="inferred0"><a name="line830"></a> 830       # === Example
</span><span class="inferred1"><a name="line831"></a> 831       #
</span><span class="inferred0"><a name="line832"></a> 832       # An Account class declares &lt;tt&gt;has_one :beneficiary&lt;/tt&gt;, which will add:
</span><span class="inferred1"><a name="line833"></a> 833       # * &lt;tt&gt;Account#beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;Beneficiary.find(:first, :conditions =&gt; &quot;account_id = #{id}&quot;)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line834"></a> 834       # * &lt;tt&gt;Account#beneficiary=(beneficiary)&lt;/tt&gt; (similar to &lt;tt&gt;beneficiary.account_id = account.id; beneficiary.save&lt;/tt&gt;)
</span><span class="inferred1"><a name="line835"></a> 835       # * &lt;tt&gt;Account#build_beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;Beneficiary.new(&quot;account_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line836"></a> 836       # * &lt;tt&gt;Account#create_beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;b = Beneficiary.new(&quot;account_id&quot; =&gt; id); b.save; b&lt;/tt&gt;)
</span><span class="inferred1"><a name="line837"></a> 837       #
</span><span class="inferred0"><a name="line838"></a> 838       # === Options
</span><span class="inferred1"><a name="line839"></a> 839       #
</span><span class="inferred0"><a name="line840"></a> 840       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred1"><a name="line841"></a> 841       #
</span><span class="inferred0"><a name="line842"></a> 842       # Options are:
</span><span class="inferred1"><a name="line843"></a> 843       # [:class_name]
</span><span class="inferred0"><a name="line844"></a> 844       #   Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred1"><a name="line845"></a> 845       #   from the association name. So &lt;tt&gt;has_one :manager&lt;/tt&gt; will by default be linked to the Manager class, but
</span><span class="inferred0"><a name="line846"></a> 846       #   if the real class name is Person, you'll have to specify it with this option.
</span><span class="inferred1"><a name="line847"></a> 847       # [:conditions]
</span><span class="inferred0"><a name="line848"></a> 848       #   Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred1"><a name="line849"></a> 849       #   SQL fragment, such as &lt;tt&gt;rank = 5&lt;/tt&gt;.
</span><span class="inferred0"><a name="line850"></a> 850       # [:order]
</span><span class="inferred1"><a name="line851"></a> 851       #   Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred0"><a name="line852"></a> 852       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;.
</span><span class="inferred1"><a name="line853"></a> 853       # [:dependent]
</span><span class="inferred0"><a name="line854"></a> 854       #   If set to &lt;tt&gt;:destroy&lt;/tt&gt;, the associated object is destroyed when this object is. If set to
</span><span class="inferred1"><a name="line855"></a> 855       #   &lt;tt&gt;:delete&lt;/tt&gt;, the associated object is deleted *without* calling its destroy method. If set to &lt;tt&gt;:nullify&lt;/tt&gt;, the associated
</span><span class="inferred0"><a name="line856"></a> 856       #   object's foreign key is set to +NULL+. Also, association is assigned.
</span><span class="inferred1"><a name="line857"></a> 857       # [:foreign_key]
</span><span class="inferred0"><a name="line858"></a> 858       #   Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred1"><a name="line859"></a> 859       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_one+ association will use &quot;person_id&quot;
</span><span class="inferred0"><a name="line860"></a> 860       #   as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred1"><a name="line861"></a> 861       # [:primary_key]
</span><span class="inferred0"><a name="line862"></a> 862       #   Specify the method that returns the primary key used for the association. By default this is +id+.
</span><span class="inferred1"><a name="line863"></a> 863       # [:include]
</span><span class="inferred0"><a name="line864"></a> 864       #   Specify second-order associations that should be eager loaded when this object is loaded.
</span><span class="inferred1"><a name="line865"></a> 865       # [:as]
</span><span class="inferred0"><a name="line866"></a> 866       #   Specifies a polymorphic interface (See &lt;tt&gt;belongs_to&lt;/tt&gt;).
</span><span class="inferred1"><a name="line867"></a> 867       # [:select]
</span><span class="inferred0"><a name="line868"></a> 868       #   By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred1"><a name="line869"></a> 869       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred0"><a name="line870"></a> 870       # [:through]
</span><span class="inferred1"><a name="line871"></a> 871       #   Specifies a Join Model through which to perform the query.  Options for &lt;tt&gt;:class_name&lt;/tt&gt; and &lt;tt&gt;:foreign_key&lt;/tt&gt;
</span><span class="inferred0"><a name="line872"></a> 872       #   are ignored, as the association uses the source reflection. You can only use a &lt;tt&gt;:through&lt;/tt&gt; query through a 
</span><span class="inferred1"><a name="line873"></a> 873       #   &lt;tt&gt;has_one&lt;/tt&gt; or &lt;tt&gt;belongs_to&lt;/tt&gt; association on the join model.
</span><span class="inferred0"><a name="line874"></a> 874       # [:source]
</span><span class="inferred1"><a name="line875"></a> 875       #   Specifies the source association name used by &lt;tt&gt;has_one :through&lt;/tt&gt; queries.  Only use it if the name cannot be
</span><span class="inferred0"><a name="line876"></a> 876       #   inferred from the association.  &lt;tt&gt;has_one :favorite, :through =&gt; :favorites&lt;/tt&gt; will look for a
</span><span class="inferred1"><a name="line877"></a> 877       #   &lt;tt&gt;:favorite&lt;/tt&gt; on Favorite, unless a &lt;tt&gt;:source&lt;/tt&gt; is given.
</span><span class="inferred0"><a name="line878"></a> 878       # [:source_type]
</span><span class="inferred1"><a name="line879"></a> 879       #   Specifies type of the source association used by &lt;tt&gt;has_one :through&lt;/tt&gt; queries where the source
</span><span class="inferred0"><a name="line880"></a> 880       #   association is a polymorphic +belongs_to+.
</span><span class="inferred1"><a name="line881"></a> 881       # [:readonly]
</span><span class="inferred0"><a name="line882"></a> 882       #   If true, the associated object is readonly through the association.
</span><span class="inferred1"><a name="line883"></a> 883       # [:validate]
</span><span class="inferred0"><a name="line884"></a> 884       #   If false, don't validate the associated object when saving the parent object. +false+ by default.
</span><span class="inferred1"><a name="line885"></a> 885       # [:autosave]
</span><span class="inferred0"><a name="line886"></a> 886       #   If true, always save the associated object or destroy it if marked for destruction, when saving the parent object. Off by default.
</span><span class="inferred1"><a name="line887"></a> 887       #
</span><span class="inferred0"><a name="line888"></a> 888       # Option examples:
</span><span class="inferred1"><a name="line889"></a> 889       #   has_one :credit_card, :dependent =&gt; :destroy  # destroys the associated credit card
</span><span class="inferred0"><a name="line890"></a> 890       #   has_one :credit_card, :dependent =&gt; :nullify  # updates the associated records foreign key value to NULL rather than destroying it
</span><span class="inferred1"><a name="line891"></a> 891       #   has_one :last_comment, :class_name =&gt; &quot;Comment&quot;, :order =&gt; &quot;posted_on&quot;
</span><span class="inferred0"><a name="line892"></a> 892       #   has_one :project_manager, :class_name =&gt; &quot;Person&quot;, :conditions =&gt; &quot;role = 'project_manager'&quot;
</span><span class="inferred1"><a name="line893"></a> 893       #   has_one :attachment, :as =&gt; :attachable
</span><span class="inferred0"><a name="line894"></a> 894       #   has_one :boss, :readonly =&gt; :true
</span><span class="inferred1"><a name="line895"></a> 895       #   has_one :club, :through =&gt; :membership
</span><span class="inferred0"><a name="line896"></a> 896       #   has_one :primary_address, :through =&gt; :addressables, :conditions =&gt; [&quot;addressable.primary = ?&quot;, true], :source =&gt; :addressable
</span><span class="marked1"><a name="line897"></a> 897       def has_one(association_id, options = {})
</span><span class="marked0"><a name="line898"></a> 898         if options[:through]
</span><span class="uncovered1"><a name="line899"></a> 899           reflection = create_has_one_through_reflection(association_id, options)
</span><span class="uncovered0"><a name="line900"></a> 900           association_accessor_methods(reflection, ActiveRecord::Associations::HasOneThroughAssociation)
</span><span class="inferred1"><a name="line901"></a> 901         else
</span><span class="marked0"><a name="line902"></a> 902           reflection = create_has_one_reflection(association_id, options)
</span><span class="marked1"><a name="line903"></a> 903           association_accessor_methods(reflection, HasOneAssociation)
</span><span class="marked0"><a name="line904"></a> 904           association_constructor_method(:build,  reflection, HasOneAssociation)
</span><span class="marked1"><a name="line905"></a> 905           association_constructor_method(:create, reflection, HasOneAssociation)
</span><span class="marked0"><a name="line906"></a> 906           configure_dependency_for_has_one(reflection)
</span><span class="inferred1"><a name="line907"></a> 907         end
</span><span class="marked0"><a name="line908"></a> 908       end
</span><span class="inferred1"><a name="line909"></a> 909 
</span><span class="inferred0"><a name="line910"></a> 910       # Specifies a one-to-one association with another class. This method should only be used
</span><span class="inferred1"><a name="line911"></a> 911       # if this class contains the foreign key. If the other class contains the foreign key,
</span><span class="inferred0"><a name="line912"></a> 912       # then you should use +has_one+ instead. See also ActiveRecord::Associations::ClassMethods's overview
</span><span class="inferred1"><a name="line913"></a> 913       # on when to use +has_one+ and when to use +belongs_to+.
</span><span class="inferred0"><a name="line914"></a> 914       #
</span><span class="inferred1"><a name="line915"></a> 915       # Methods will be added for retrieval and query for a single associated object, for which
</span><span class="inferred0"><a name="line916"></a> 916       # this object holds an id:
</span><span class="inferred1"><a name="line917"></a> 917       #
</span><span class="inferred0"><a name="line918"></a> 918       # [association(force_reload = false)]
</span><span class="inferred1"><a name="line919"></a> 919       #   Returns the associated object. +nil+ is returned if none is found.
</span><span class="inferred0"><a name="line920"></a> 920       # [association=(associate)]
</span><span class="inferred1"><a name="line921"></a> 921       #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.
</span><span class="inferred0"><a name="line922"></a> 922       # [build_association(attributes = {})]
</span><span class="inferred1"><a name="line923"></a> 923       #   Returns a new object of the associated type that has been instantiated
</span><span class="inferred0"><a name="line924"></a> 924       #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
</span><span class="inferred1"><a name="line925"></a> 925       # [create_association(attributes = {})]
</span><span class="inferred0"><a name="line926"></a> 926       #   Returns a new object of the associated type that has been instantiated
</span><span class="inferred1"><a name="line927"></a> 927       #   with +attributes+, linked to this object through a foreign key, and that
</span><span class="inferred0"><a name="line928"></a> 928       #   has already been saved (if it passed the validation).
</span><span class="inferred1"><a name="line929"></a> 929       #
</span><span class="inferred0"><a name="line930"></a> 930       # (+association+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred1"><a name="line931"></a> 931       # &lt;tt&gt;belongs_to :author&lt;/tt&gt; would add among others &lt;tt&gt;author.nil?&lt;/tt&gt;.)
</span><span class="inferred0"><a name="line932"></a> 932       #
</span><span class="inferred1"><a name="line933"></a> 933       # === Example
</span><span class="inferred0"><a name="line934"></a> 934       #
</span><span class="inferred1"><a name="line935"></a> 935       # A Post class declares &lt;tt&gt;belongs_to :author&lt;/tt&gt;, which will add:
</span><span class="inferred0"><a name="line936"></a> 936       # * &lt;tt&gt;Post#author&lt;/tt&gt; (similar to &lt;tt&gt;Author.find(author_id)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line937"></a> 937       # * &lt;tt&gt;Post#author=(author)&lt;/tt&gt; (similar to &lt;tt&gt;post.author_id = author.id&lt;/tt&gt;)
</span><span class="inferred0"><a name="line938"></a> 938       # * &lt;tt&gt;Post#author?&lt;/tt&gt; (similar to &lt;tt&gt;post.author == some_author&lt;/tt&gt;)
</span><span class="inferred1"><a name="line939"></a> 939       # * &lt;tt&gt;Post#build_author&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new&lt;/tt&gt;)
</span><span class="inferred0"><a name="line940"></a> 940       # * &lt;tt&gt;Post#create_author&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new; post.author.save; post.author&lt;/tt&gt;)
</span><span class="inferred1"><a name="line941"></a> 941       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred0"><a name="line942"></a> 942       #
</span><span class="inferred1"><a name="line943"></a> 943       # === Options
</span><span class="inferred0"><a name="line944"></a> 944       #
</span><span class="inferred1"><a name="line945"></a> 945       # [:class_name]
</span><span class="inferred0"><a name="line946"></a> 946       #   Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred1"><a name="line947"></a> 947       #   from the association name. So &lt;tt&gt;has_one :author&lt;/tt&gt; will by default be linked to the Author class, but
</span><span class="inferred0"><a name="line948"></a> 948       #   if the real class name is Person, you'll have to specify it with this option.
</span><span class="inferred1"><a name="line949"></a> 949       # [:conditions]
</span><span class="inferred0"><a name="line950"></a> 950       #   Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred1"><a name="line951"></a> 951       #   SQL fragment, such as &lt;tt&gt;authorized = 1&lt;/tt&gt;.
</span><span class="inferred0"><a name="line952"></a> 952       # [:select]
</span><span class="inferred1"><a name="line953"></a> 953       #   By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred0"><a name="line954"></a> 954       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred1"><a name="line955"></a> 955       # [:foreign_key]
</span><span class="inferred0"><a name="line956"></a> 956       #   Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred1"><a name="line957"></a> 957       #   of the association with an &quot;_id&quot; suffix. So a class that defines a &lt;tt&gt;belongs_to :person&lt;/tt&gt; association will use
</span><span class="inferred0"><a name="line958"></a> 958       #   &quot;person_id&quot; as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;. Similarly, &lt;tt&gt;belongs_to :favorite_person, :class_name =&gt; &quot;Person&quot;&lt;/tt&gt;
</span><span class="inferred1"><a name="line959"></a> 959       #   will use a foreign key of &quot;favorite_person_id&quot;.
</span><span class="inferred0"><a name="line960"></a> 960       # [:dependent]
</span><span class="inferred1"><a name="line961"></a> 961       #   If set to &lt;tt&gt;:destroy&lt;/tt&gt;, the associated object is destroyed when this object is. If set to
</span><span class="inferred0"><a name="line962"></a> 962       #   &lt;tt&gt;:delete&lt;/tt&gt;, the associated object is deleted *without* calling its destroy method. This option should not be specified when
</span><span class="inferred1"><a name="line963"></a> 963       #   &lt;tt&gt;belongs_to&lt;/tt&gt; is used in conjunction with a &lt;tt&gt;has_many&lt;/tt&gt; relationship on another class because of the potential to leave
</span><span class="inferred0"><a name="line964"></a> 964       #   orphaned records behind.
</span><span class="inferred1"><a name="line965"></a> 965       # [:counter_cache]
</span><span class="inferred0"><a name="line966"></a> 966       #   Caches the number of belonging objects on the associate class through the use of +increment_counter+
</span><span class="inferred1"><a name="line967"></a> 967       #   and +decrement_counter+. The counter cache is incremented when an object of this class is created and decremented when it's
</span><span class="inferred0"><a name="line968"></a> 968       #   destroyed. This requires that a column named &lt;tt&gt;#{table_name}_count&lt;/tt&gt; (such as +comments_count+ for a belonging Comment class)
</span><span class="inferred1"><a name="line969"></a> 969       #   is used on the associate class (such as a Post class). You can also specify a custom counter cache column by providing
</span><span class="inferred0"><a name="line970"></a> 970       #   a column name instead of a +true+/+false+ value to this option (e.g., &lt;tt&gt;:counter_cache =&gt; :my_custom_counter&lt;/tt&gt;.)
</span><span class="inferred1"><a name="line971"></a> 971       #   Note: Specifying a counter cache will add it to that model's list of readonly attributes using +attr_readonly+.
</span><span class="inferred0"><a name="line972"></a> 972       # [:include]
</span><span class="inferred1"><a name="line973"></a> 973       #   Specify second-order associations that should be eager loaded when this object is loaded.
</span><span class="inferred0"><a name="line974"></a> 974       # [:polymorphic]
</span><span class="inferred1"><a name="line975"></a> 975       #   Specify this association is a polymorphic association by passing +true+.
</span><span class="inferred0"><a name="line976"></a> 976       #   Note: If you've enabled the counter cache, then you may want to add the counter cache attribute
</span><span class="inferred1"><a name="line977"></a> 977       #   to the +attr_readonly+ list in the associated classes (e.g. &lt;tt&gt;class Post; attr_readonly :comments_count; end&lt;/tt&gt;).
</span><span class="inferred0"><a name="line978"></a> 978       # [:readonly]
</span><span class="inferred1"><a name="line979"></a> 979       #   If true, the associated object is readonly through the association.
</span><span class="inferred0"><a name="line980"></a> 980       # [:validate]
</span><span class="inferred1"><a name="line981"></a> 981       #   If false, don't validate the associated objects when saving the parent object. +false+ by default.
</span><span class="inferred0"><a name="line982"></a> 982       # [:autosave]
</span><span class="inferred1"><a name="line983"></a> 983       #   If true, always save the associated object or destroy it if marked for destruction, when saving the parent object. Off by default.
</span><span class="inferred0"><a name="line984"></a> 984       #
</span><span class="inferred1"><a name="line985"></a> 985       # Option examples:
</span><span class="inferred0"><a name="line986"></a> 986       #   belongs_to :firm, :foreign_key =&gt; &quot;client_of&quot;
</span><span class="inferred1"><a name="line987"></a> 987       #   belongs_to :author, :class_name =&gt; &quot;Person&quot;, :foreign_key =&gt; &quot;author_id&quot;
</span><span class="inferred0"><a name="line988"></a> 988       #   belongs_to :valid_coupon, :class_name =&gt; &quot;Coupon&quot;, :foreign_key =&gt; &quot;coupon_id&quot;,
</span><span class="inferred1"><a name="line989"></a> 989       #              :conditions =&gt; 'discounts &gt; #{payments_count}'
</span><span class="inferred0"><a name="line990"></a> 990       #   belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred1"><a name="line991"></a> 991       #   belongs_to :project, :readonly =&gt; true
</span><span class="inferred0"><a name="line992"></a> 992       #   belongs_to :post, :counter_cache =&gt; true
</span><span class="marked1"><a name="line993"></a> 993       def belongs_to(association_id, options = {})
</span><span class="marked0"><a name="line994"></a> 994         reflection = create_belongs_to_reflection(association_id, options)
</span><span class="inferred1"><a name="line995"></a> 995 
</span><span class="marked0"><a name="line996"></a> 996         if reflection.options[:polymorphic]
</span><span class="uncovered1"><a name="line997"></a> 997           association_accessor_methods(reflection, BelongsToPolymorphicAssociation)
</span><span class="inferred0"><a name="line998"></a> 998         else
</span><span class="marked1"><a name="line999"></a> 999           association_accessor_methods(reflection, BelongsToAssociation)
</span><span class="marked0"><a name="line1000"></a>1000           association_constructor_method(:build,  reflection, BelongsToAssociation)
</span><span class="marked1"><a name="line1001"></a>1001           association_constructor_method(:create, reflection, BelongsToAssociation)
</span><span class="inferred0"><a name="line1002"></a>1002         end
</span><span class="inferred1"><a name="line1003"></a>1003 
</span><span class="inferred0"><a name="line1004"></a>1004         # Create the callbacks to update counter cache
</span><span class="marked1"><a name="line1005"></a>1005         if options[:counter_cache]
</span><span class="uncovered0"><a name="line1006"></a>1006           cache_column = reflection.counter_cache_column
</span><span class="uncovered1"><a name="line1007"></a>1007 
</span><span class="uncovered0"><a name="line1008"></a>1008           method_name = &quot;belongs_to_counter_cache_after_create_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1009"></a>1009           define_method(method_name) do
</span><span class="uncovered0"><a name="line1010"></a>1010             association = send(reflection.name)
</span><span class="uncovered1"><a name="line1011"></a>1011             association.class.increment_counter(cache_column, send(reflection.primary_key_name)) unless association.nil?
</span><span class="uncovered0"><a name="line1012"></a>1012           end
</span><span class="uncovered1"><a name="line1013"></a>1013           after_create method_name
</span><span class="uncovered0"><a name="line1014"></a>1014 
</span><span class="uncovered1"><a name="line1015"></a>1015           method_name = &quot;belongs_to_counter_cache_before_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1016"></a>1016           define_method(method_name) do
</span><span class="uncovered1"><a name="line1017"></a>1017             association = send(reflection.name)
</span><span class="uncovered0"><a name="line1018"></a>1018             association.class.decrement_counter(cache_column, send(reflection.primary_key_name)) unless association.nil?
</span><span class="uncovered1"><a name="line1019"></a>1019           end
</span><span class="uncovered0"><a name="line1020"></a>1020           before_destroy method_name
</span><span class="uncovered1"><a name="line1021"></a>1021 
</span><span class="uncovered0"><a name="line1022"></a>1022           module_eval(
</span><span class="uncovered1"><a name="line1023"></a>1023             &quot;#{reflection.class_name}.send(:attr_readonly,\&quot;#{cache_column}\&quot;.intern) if defined?(#{reflection.class_name}) &amp;&amp; #{reflection.class_name}.respond_to?(:attr_readonly)&quot;
</span><span class="uncovered0"><a name="line1024"></a>1024           )
</span><span class="uncovered1"><a name="line1025"></a>1025         end
</span><span class="inferred0"><a name="line1026"></a>1026 
</span><span class="marked1"><a name="line1027"></a>1027         configure_dependency_for_belongs_to(reflection)
</span><span class="inferred0"><a name="line1028"></a>1028       end
</span><span class="inferred1"><a name="line1029"></a>1029 
</span><span class="inferred0"><a name="line1030"></a>1030       # Specifies a many-to-many relationship with another class. This associates two classes via an
</span><span class="inferred1"><a name="line1031"></a>1031       # intermediate join table.  Unless the join table is explicitly specified as an option, it is
</span><span class="inferred0"><a name="line1032"></a>1032       # guessed using the lexical order of the class names. So a join between Developer and Project
</span><span class="inferred1"><a name="line1033"></a>1033       # will give the default join table name of &quot;developers_projects&quot; because &quot;D&quot; outranks &quot;P&quot;.  Note that this precedence
</span><span class="inferred0"><a name="line1034"></a>1034       # is calculated using the &lt;tt&gt;&lt;&lt;/tt&gt; operator for String.  This means that if the strings are of different lengths,
</span><span class="inferred1"><a name="line1035"></a>1035       # and the strings are equal when compared up to the shortest length, then the longer string is considered of higher
</span><span class="inferred0"><a name="line1036"></a>1036       # lexical precedence than the shorter one.  For example, one would expect the tables &quot;paper_boxes&quot; and &quot;papers&quot;
</span><span class="inferred1"><a name="line1037"></a>1037       # to generate a join table name of &quot;papers_paper_boxes&quot; because of the length of the name &quot;paper_boxes&quot;,
</span><span class="inferred0"><a name="line1038"></a>1038       # but it in fact generates a join table name of &quot;paper_boxes_papers&quot;.  Be aware of this caveat, and use the
</span><span class="inferred1"><a name="line1039"></a>1039       # custom &lt;tt&gt;:join_table&lt;/tt&gt; option if you need to.
</span><span class="inferred0"><a name="line1040"></a>1040       #
</span><span class="inferred1"><a name="line1041"></a>1041       # The join table should not have a primary key or a model associated with it. You must manually generate the
</span><span class="inferred0"><a name="line1042"></a>1042       # join table with a migration such as this:
</span><span class="inferred1"><a name="line1043"></a>1043       #
</span><span class="inferred0"><a name="line1044"></a>1044       #   class CreateDevelopersProjectsJoinTable &lt; ActiveRecord::Migration
</span><span class="inferred1"><a name="line1045"></a>1045       #     def self.up
</span><span class="inferred0"><a name="line1046"></a>1046       #       create_table :developers_projects, :id =&gt; false do |t|
</span><span class="inferred1"><a name="line1047"></a>1047       #         t.integer :developer_id
</span><span class="inferred0"><a name="line1048"></a>1048       #         t.integer :project_id
</span><span class="inferred1"><a name="line1049"></a>1049       #       end
</span><span class="inferred0"><a name="line1050"></a>1050       #     end
</span><span class="inferred1"><a name="line1051"></a>1051       #
</span><span class="inferred0"><a name="line1052"></a>1052       #     def self.down
</span><span class="inferred1"><a name="line1053"></a>1053       #       drop_table :developers_projects
</span><span class="inferred0"><a name="line1054"></a>1054       #     end
</span><span class="inferred1"><a name="line1055"></a>1055       #   end
</span><span class="inferred0"><a name="line1056"></a>1056       #
</span><span class="inferred1"><a name="line1057"></a>1057       # Deprecated: Any additional fields added to the join table will be placed as attributes when pulling records out through
</span><span class="inferred0"><a name="line1058"></a>1058       # +has_and_belongs_to_many+ associations. Records returned from join tables with additional attributes will be marked as
</span><span class="inferred1"><a name="line1059"></a>1059       # readonly (because we can't save changes to the additional attributes). It's strongly recommended that you upgrade any
</span><span class="inferred0"><a name="line1060"></a>1060       # associations with attributes to a real join model (see introduction).
</span><span class="inferred1"><a name="line1061"></a>1061       #
</span><span class="inferred0"><a name="line1062"></a>1062       # Adds the following methods for retrieval and query:
</span><span class="inferred1"><a name="line1063"></a>1063       #
</span><span class="inferred0"><a name="line1064"></a>1064       # [collection(force_reload = false)]
</span><span class="inferred1"><a name="line1065"></a>1065       #   Returns an array of all the associated objects.
</span><span class="inferred0"><a name="line1066"></a>1066       #   An empty array is returned if none are found.
</span><span class="inferred1"><a name="line1067"></a>1067       # [collection&lt;&lt;(object, ...)]
</span><span class="inferred0"><a name="line1068"></a>1068       #   Adds one or more objects to the collection by creating associations in the join table
</span><span class="inferred1"><a name="line1069"></a>1069       #   (&lt;tt&gt;collection.push&lt;/tt&gt; and &lt;tt&gt;collection.concat&lt;/tt&gt; are aliases to this method).
</span><span class="inferred0"><a name="line1070"></a>1070       # [collection.delete(object, ...)]
</span><span class="inferred1"><a name="line1071"></a>1071       #   Removes one or more objects from the collection by removing their associations from the join table.
</span><span class="inferred0"><a name="line1072"></a>1072       #   This does not destroy the objects.
</span><span class="inferred1"><a name="line1073"></a>1073       # [collection=objects]
</span><span class="inferred0"><a name="line1074"></a>1074       #   Replaces the collection's content by deleting and adding objects as appropriate.
</span><span class="inferred1"><a name="line1075"></a>1075       # [collection_singular_ids]
</span><span class="inferred0"><a name="line1076"></a>1076       #   Returns an array of the associated objects' ids.
</span><span class="inferred1"><a name="line1077"></a>1077       # [collection_singular_ids=ids]
</span><span class="inferred0"><a name="line1078"></a>1078       #   Replace the collection by the objects identified by the primary keys in +ids+.
</span><span class="inferred1"><a name="line1079"></a>1079       # [collection.clear]
</span><span class="inferred0"><a name="line1080"></a>1080       #   Removes every object from the collection. This does not destroy the objects.
</span><span class="inferred1"><a name="line1081"></a>1081       # [collection.empty?]
</span><span class="inferred0"><a name="line1082"></a>1082       #   Returns +true+ if there are no associated objects.
</span><span class="inferred1"><a name="line1083"></a>1083       # [collection.size]
</span><span class="inferred0"><a name="line1084"></a>1084       #   Returns the number of associated objects.
</span><span class="inferred1"><a name="line1085"></a>1085       # [collection.find(id)]
</span><span class="inferred0"><a name="line1086"></a>1086       #   Finds an associated object responding to the +id+ and that
</span><span class="inferred1"><a name="line1087"></a>1087       #   meets the condition that it has to be associated with this object.
</span><span class="inferred0"><a name="line1088"></a>1088       #   Uses the same rules as ActiveRecord::Base.find.
</span><span class="inferred1"><a name="line1089"></a>1089       # [collection.exists?(...)]
</span><span class="inferred0"><a name="line1090"></a>1090       #   Checks whether an associated object with the given conditions exists.
</span><span class="inferred1"><a name="line1091"></a>1091       #   Uses the same rules as ActiveRecord::Base.exists?.
</span><span class="inferred0"><a name="line1092"></a>1092       # [collection.build(attributes = {})]
</span><span class="inferred1"><a name="line1093"></a>1093       #   Returns a new object of the collection type that has been instantiated
</span><span class="inferred0"><a name="line1094"></a>1094       #   with +attributes+ and linked to this object through the join table, but has not yet been saved.
</span><span class="inferred1"><a name="line1095"></a>1095       # [collection.create(attributes = {})]
</span><span class="inferred0"><a name="line1096"></a>1096       #   Returns a new object of the collection type that has been instantiated
</span><span class="inferred1"><a name="line1097"></a>1097       #   with +attributes+, linked to this object through the join table, and that has already been saved (if it passed the validation).
</span><span class="inferred0"><a name="line1098"></a>1098       #
</span><span class="inferred1"><a name="line1099"></a>1099       # (+collection+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred0"><a name="line1100"></a>1100       # &lt;tt&gt;has_and_belongs_to_many :categories&lt;/tt&gt; would add among others &lt;tt&gt;categories.empty?&lt;/tt&gt;.)
</span><span class="inferred1"><a name="line1101"></a>1101       #
</span><span class="inferred0"><a name="line1102"></a>1102       # === Example
</span><span class="inferred1"><a name="line1103"></a>1103       #
</span><span class="inferred0"><a name="line1104"></a>1104       # A Developer class declares &lt;tt&gt;has_and_belongs_to_many :projects&lt;/tt&gt;, which will add:
</span><span class="inferred1"><a name="line1105"></a>1105       # * &lt;tt&gt;Developer#projects&lt;/tt&gt;
</span><span class="inferred0"><a name="line1106"></a>1106       # * &lt;tt&gt;Developer#projects&lt;&lt;&lt;/tt&gt;
</span><span class="inferred1"><a name="line1107"></a>1107       # * &lt;tt&gt;Developer#projects.delete&lt;/tt&gt;
</span><span class="inferred0"><a name="line1108"></a>1108       # * &lt;tt&gt;Developer#projects=&lt;/tt&gt;
</span><span class="inferred1"><a name="line1109"></a>1109       # * &lt;tt&gt;Developer#project_ids&lt;/tt&gt;
</span><span class="inferred0"><a name="line1110"></a>1110       # * &lt;tt&gt;Developer#project_ids=&lt;/tt&gt;
</span><span class="inferred1"><a name="line1111"></a>1111       # * &lt;tt&gt;Developer#projects.clear&lt;/tt&gt;
</span><span class="inferred0"><a name="line1112"></a>1112       # * &lt;tt&gt;Developer#projects.empty?&lt;/tt&gt;
</span><span class="inferred1"><a name="line1113"></a>1113       # * &lt;tt&gt;Developer#projects.size&lt;/tt&gt;
</span><span class="inferred0"><a name="line1114"></a>1114       # * &lt;tt&gt;Developer#projects.find(id)&lt;/tt&gt;
</span><span class="inferred1"><a name="line1115"></a>1115       # * &lt;tt&gt;Developer#clients.exists?(...)&lt;/tt&gt;
</span><span class="inferred0"><a name="line1116"></a>1116       # * &lt;tt&gt;Developer#projects.build&lt;/tt&gt; (similar to &lt;tt&gt;Project.new(&quot;project_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line1117"></a>1117       # * &lt;tt&gt;Developer#projects.create&lt;/tt&gt; (similar to &lt;tt&gt;c = Project.new(&quot;project_id&quot; =&gt; id); c.save; c&lt;/tt&gt;)
</span><span class="inferred0"><a name="line1118"></a>1118       # The declaration may include an options hash to specialize the behavior of the association.
</span><span class="inferred1"><a name="line1119"></a>1119       #
</span><span class="inferred0"><a name="line1120"></a>1120       # === Options
</span><span class="inferred1"><a name="line1121"></a>1121       #
</span><span class="inferred0"><a name="line1122"></a>1122       # [:class_name]
</span><span class="inferred1"><a name="line1123"></a>1123       #   Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred0"><a name="line1124"></a>1124       #   from the association name. So &lt;tt&gt;has_and_belongs_to_many :projects&lt;/tt&gt; will by default be linked to the
</span><span class="inferred1"><a name="line1125"></a>1125       #   Project class, but if the real class name is SuperProject, you'll have to specify it with this option.
</span><span class="inferred0"><a name="line1126"></a>1126       # [:join_table]
</span><span class="inferred1"><a name="line1127"></a>1127       #   Specify the name of the join table if the default based on lexical order isn't what you want.
</span><span class="inferred0"><a name="line1128"></a>1128       #   &lt;b&gt;WARNING:&lt;/b&gt; If you're overwriting the table name of either class, the +table_name+ method
</span><span class="inferred1"><a name="line1129"></a>1129       #   MUST be declared underneath any +has_and_belongs_to_many+ declaration in order to work.
</span><span class="inferred0"><a name="line1130"></a>1130       # [:foreign_key]
</span><span class="inferred1"><a name="line1131"></a>1131       #   Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred0"><a name="line1132"></a>1132       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_and_belongs_to_many+ association
</span><span class="inferred1"><a name="line1133"></a>1133       #   to Project will use &quot;person_id&quot; as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred0"><a name="line1134"></a>1134       # [:association_foreign_key]
</span><span class="inferred1"><a name="line1135"></a>1135       #   Specify the foreign key used for the association on the receiving side of the association.
</span><span class="inferred0"><a name="line1136"></a>1136       #   By default this is guessed to be the name of the associated class in lower-case and &quot;_id&quot; suffixed.
</span><span class="inferred1"><a name="line1137"></a>1137       #   So if a Person class makes a +has_and_belongs_to_many+ association to Project,
</span><span class="inferred0"><a name="line1138"></a>1138       #   the association will use &quot;project_id&quot; as the default &lt;tt&gt;:association_foreign_key&lt;/tt&gt;.
</span><span class="inferred1"><a name="line1139"></a>1139       # [:conditions]
</span><span class="inferred0"><a name="line1140"></a>1140       #   Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred1"><a name="line1141"></a>1141       #   SQL fragment, such as &lt;tt&gt;authorized = 1&lt;/tt&gt;.  Record creations from the association are scoped if a hash is used.  
</span><span class="inferred0"><a name="line1142"></a>1142       #   &lt;tt&gt;has_many :posts, :conditions =&gt; {:published =&gt; true}&lt;/tt&gt; will create published posts with &lt;tt&gt;@blog.posts.create&lt;/tt&gt; 
</span><span class="inferred1"><a name="line1143"></a>1143       #   or &lt;tt&gt;@blog.posts.build&lt;/tt&gt;.
</span><span class="inferred0"><a name="line1144"></a>1144       # [:order]
</span><span class="inferred1"><a name="line1145"></a>1145       #   Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred0"><a name="line1146"></a>1146       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;
</span><span class="inferred1"><a name="line1147"></a>1147       # [:uniq]
</span><span class="inferred0"><a name="line1148"></a>1148       #   If true, duplicate associated objects will be ignored by accessors and query methods.
</span><span class="inferred1"><a name="line1149"></a>1149       # [:finder_sql]
</span><span class="inferred0"><a name="line1150"></a>1150       #   Overwrite the default generated SQL statement used to fetch the association with a manual statement
</span><span class="inferred1"><a name="line1151"></a>1151       # [:counter_sql]
</span><span class="inferred0"><a name="line1152"></a>1152       #   Specify a complete SQL statement to fetch the size of the association. If &lt;tt&gt;:finder_sql&lt;/tt&gt; is
</span><span class="inferred1"><a name="line1153"></a>1153       #   specified but not &lt;tt&gt;:counter_sql&lt;/tt&gt;, &lt;tt&gt;:counter_sql&lt;/tt&gt; will be generated by replacing &lt;tt&gt;SELECT ... FROM&lt;/tt&gt; with &lt;tt&gt;SELECT COUNT(*) FROM&lt;/tt&gt;.
</span><span class="inferred0"><a name="line1154"></a>1154       # [:delete_sql]
</span><span class="inferred1"><a name="line1155"></a>1155       #   Overwrite the default generated SQL statement used to remove links between the associated
</span><span class="inferred0"><a name="line1156"></a>1156       #   classes with a manual statement.
</span><span class="inferred1"><a name="line1157"></a>1157       # [:insert_sql]
</span><span class="inferred0"><a name="line1158"></a>1158       #   Overwrite the default generated SQL statement used to add links between the associated classes
</span><span class="inferred1"><a name="line1159"></a>1159       #   with a manual statement.
</span><span class="inferred0"><a name="line1160"></a>1160       # [:extend]
</span><span class="inferred1"><a name="line1161"></a>1161       #   Anonymous module for extending the proxy, see &quot;Association extensions&quot;.
</span><span class="inferred0"><a name="line1162"></a>1162       # [:include]
</span><span class="inferred1"><a name="line1163"></a>1163       #   Specify second-order associations that should be eager loaded when the collection is loaded.
</span><span class="inferred0"><a name="line1164"></a>1164       # [:group]
</span><span class="inferred1"><a name="line1165"></a>1165       #   An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred0"><a name="line1166"></a>1166       # [:having]
</span><span class="inferred1"><a name="line1167"></a>1167       #   Combined with +:group+ this can be used to filter the records that a &lt;tt&gt;GROUP BY&lt;/tt&gt; returns. Uses the &lt;tt&gt;HAVING&lt;/tt&gt; SQL-clause.
</span><span class="inferred0"><a name="line1168"></a>1168       # [:limit]
</span><span class="inferred1"><a name="line1169"></a>1169       #   An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred0"><a name="line1170"></a>1170       # [:offset]
</span><span class="inferred1"><a name="line1171"></a>1171       #   An integer determining the offset from where the rows should be fetched. So at 5, it would skip the first 4 rows.
</span><span class="inferred0"><a name="line1172"></a>1172       # [:select]
</span><span class="inferred1"><a name="line1173"></a>1173       #   By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred0"><a name="line1174"></a>1174       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred1"><a name="line1175"></a>1175       # [:readonly]
</span><span class="inferred0"><a name="line1176"></a>1176       #   If true, all the associated objects are readonly through the association.
</span><span class="inferred1"><a name="line1177"></a>1177       # [:validate]
</span><span class="inferred0"><a name="line1178"></a>1178       #   If false, don't validate the associated objects when saving the parent object. +true+ by default.
</span><span class="inferred1"><a name="line1179"></a>1179       # [:autosave]
</span><span class="inferred0"><a name="line1180"></a>1180       #   If true, always save any loaded members and destroy members marked for destruction, when saving the parent object. Off by default.
</span><span class="inferred1"><a name="line1181"></a>1181       #
</span><span class="inferred0"><a name="line1182"></a>1182       # Option examples:
</span><span class="inferred1"><a name="line1183"></a>1183       #   has_and_belongs_to_many :projects
</span><span class="inferred0"><a name="line1184"></a>1184       #   has_and_belongs_to_many :projects, :include =&gt; [ :milestones, :manager ]
</span><span class="inferred1"><a name="line1185"></a>1185       #   has_and_belongs_to_many :nations, :class_name =&gt; &quot;Country&quot;
</span><span class="inferred0"><a name="line1186"></a>1186       #   has_and_belongs_to_many :categories, :join_table =&gt; &quot;prods_cats&quot;
</span><span class="inferred1"><a name="line1187"></a>1187       #   has_and_belongs_to_many :categories, :readonly =&gt; true
</span><span class="inferred0"><a name="line1188"></a>1188       #   has_and_belongs_to_many :active_projects, :join_table =&gt; 'developers_projects', :delete_sql =&gt;
</span><span class="inferred1"><a name="line1189"></a>1189       #   'DELETE FROM developers_projects WHERE active=1 AND developer_id = #{id} AND project_id = #{record.id}'
</span><span class="marked0"><a name="line1190"></a>1190       def has_and_belongs_to_many(association_id, options = {}, &amp;extension)
</span><span class="uncovered1"><a name="line1191"></a>1191         reflection = create_has_and_belongs_to_many_reflection(association_id, options, &amp;extension)
</span><span class="uncovered0"><a name="line1192"></a>1192         collection_accessor_methods(reflection, HasAndBelongsToManyAssociation)
</span><span class="uncovered1"><a name="line1193"></a>1193 
</span><span class="uncovered0"><a name="line1194"></a>1194         # Don't use a before_destroy callback since users' before_destroy
</span><span class="uncovered1"><a name="line1195"></a>1195         # callbacks will be executed after the association is wiped out.
</span><span class="uncovered0"><a name="line1196"></a>1196         old_method = &quot;destroy_without_habtm_shim_for_#{reflection.name}&quot;
</span><span class="uncovered1"><a name="line1197"></a>1197         class_eval &lt;&lt;-end_eval unless method_defined?(old_method)
</span><span class="uncovered0"><a name="line1198"></a>1198           alias_method :#{old_method}, :destroy_without_callbacks  # alias_method :destroy_without_habtm_shim_for_posts, :destroy_without_callbacks
</span><span class="uncovered1"><a name="line1199"></a>1199           def destroy_without_callbacks                            # def destroy_without_callbacks
</span><span class="uncovered0"><a name="line1200"></a>1200             #{reflection.name}.clear                               #   posts.clear
</span><span class="uncovered1"><a name="line1201"></a>1201             #{old_method}                                          #   destroy_without_habtm_shim_for_posts
</span><span class="uncovered0"><a name="line1202"></a>1202           end                                                      # end
</span><span class="uncovered1"><a name="line1203"></a>1203         end_eval
</span><span class="uncovered0"><a name="line1204"></a>1204 
</span><span class="uncovered1"><a name="line1205"></a>1205         add_association_callbacks(reflection.name, options)
</span><span class="uncovered0"><a name="line1206"></a>1206       end
</span><span class="inferred1"><a name="line1207"></a>1207 
</span><span class="marked0"><a name="line1208"></a>1208       private
</span><span class="inferred1"><a name="line1209"></a>1209         # Generates a join table name from two provided table names.
</span><span class="inferred0"><a name="line1210"></a>1210         # The names in the join table namesme end up in lexicographic order.
</span><span class="inferred1"><a name="line1211"></a>1211         #
</span><span class="inferred0"><a name="line1212"></a>1212         #   join_table_name(&quot;members&quot;, &quot;clubs&quot;)         # =&gt; &quot;clubs_members&quot;
</span><span class="inferred1"><a name="line1213"></a>1213         #   join_table_name(&quot;members&quot;, &quot;special_clubs&quot;) # =&gt; &quot;members_special_clubs&quot;
</span><span class="marked0"><a name="line1214"></a>1214         def join_table_name(first_table_name, second_table_name)
</span><span class="uncovered1"><a name="line1215"></a>1215           if first_table_name &lt; second_table_name
</span><span class="uncovered0"><a name="line1216"></a>1216             join_table = &quot;#{first_table_name}_#{second_table_name}&quot;
</span><span class="uncovered1"><a name="line1217"></a>1217           else
</span><span class="uncovered0"><a name="line1218"></a>1218             join_table = &quot;#{second_table_name}_#{first_table_name}&quot;
</span><span class="uncovered1"><a name="line1219"></a>1219           end
</span><span class="uncovered0"><a name="line1220"></a>1220 
</span><span class="uncovered1"><a name="line1221"></a>1221           table_name_prefix + join_table + table_name_suffix
</span><span class="uncovered0"><a name="line1222"></a>1222         end
</span><span class="inferred1"><a name="line1223"></a>1223 
</span><span class="marked0"><a name="line1224"></a>1224         def association_accessor_methods(reflection, association_proxy_class)
</span><span class="marked1"><a name="line1225"></a>1225           define_method(reflection.name) do |*params|
</span><span class="marked0"><a name="line1226"></a>1226             force_reload = params.first unless params.empty?
</span><span class="marked1"><a name="line1227"></a>1227             association = association_instance_get(reflection.name)
</span><span class="inferred0"><a name="line1228"></a>1228 
</span><span class="marked1"><a name="line1229"></a>1229             if association.nil? || force_reload
</span><span class="uncovered0"><a name="line1230"></a>1230               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered1"><a name="line1231"></a>1231               retval = association.reload
</span><span class="uncovered0"><a name="line1232"></a>1232               if retval.nil? and association_proxy_class == BelongsToAssociation
</span><span class="uncovered1"><a name="line1233"></a>1233                 association_instance_set(reflection.name, nil)
</span><span class="uncovered0"><a name="line1234"></a>1234                 return nil
</span><span class="uncovered1"><a name="line1235"></a>1235               end
</span><span class="uncovered0"><a name="line1236"></a>1236               association_instance_set(reflection.name, association)
</span><span class="uncovered1"><a name="line1237"></a>1237             end
</span><span class="inferred0"><a name="line1238"></a>1238 
</span><span class="marked1"><a name="line1239"></a>1239             association.target.nil? ? nil : association
</span><span class="inferred0"><a name="line1240"></a>1240           end
</span><span class="inferred1"><a name="line1241"></a>1241 
</span><span class="marked0"><a name="line1242"></a>1242           define_method(&quot;loaded_#{reflection.name}?&quot;) do
</span><span class="uncovered1"><a name="line1243"></a>1243             association = association_instance_get(reflection.name)
</span><span class="uncovered0"><a name="line1244"></a>1244             association &amp;&amp; association.loaded?
</span><span class="uncovered1"><a name="line1245"></a>1245           end
</span><span class="inferred0"><a name="line1246"></a>1246 
</span><span class="marked1"><a name="line1247"></a>1247           define_method(&quot;#{reflection.name}=&quot;) do |new_value|
</span><span class="marked0"><a name="line1248"></a>1248             association = association_instance_get(reflection.name)
</span><span class="inferred1"><a name="line1249"></a>1249 
</span><span class="marked0"><a name="line1250"></a>1250             if association.nil? || association.target != new_value
</span><span class="marked1"><a name="line1251"></a>1251               association = association_proxy_class.new(self, reflection)
</span><span class="inferred0"><a name="line1252"></a>1252             end
</span><span class="inferred1"><a name="line1253"></a>1253 
</span><span class="marked0"><a name="line1254"></a>1254             if association_proxy_class == HasOneThroughAssociation
</span><span class="uncovered1"><a name="line1255"></a>1255               association.create_through_record(new_value)
</span><span class="uncovered0"><a name="line1256"></a>1256               self.send(reflection.name, new_value)
</span><span class="inferred1"><a name="line1257"></a>1257             else
</span><span class="marked0"><a name="line1258"></a>1258               association.replace(new_value)
</span><span class="marked1"><a name="line1259"></a>1259               association_instance_set(reflection.name, new_value.nil? ? nil : association)
</span><span class="inferred0"><a name="line1260"></a>1260             end
</span><span class="inferred1"><a name="line1261"></a>1261           end
</span><span class="inferred0"><a name="line1262"></a>1262 
</span><span class="marked1"><a name="line1263"></a>1263           define_method(&quot;set_#{reflection.name}_target&quot;) do |target|
</span><span class="uncovered0"><a name="line1264"></a>1264             return if target.nil? and association_proxy_class == BelongsToAssociation
</span><span class="uncovered1"><a name="line1265"></a>1265             association = association_proxy_class.new(self, reflection)
</span><span class="uncovered0"><a name="line1266"></a>1266             association.target = target
</span><span class="uncovered1"><a name="line1267"></a>1267             association_instance_set(reflection.name, association)
</span><span class="uncovered0"><a name="line1268"></a>1268           end
</span><span class="uncovered1"><a name="line1269"></a>1269         end
</span><span class="inferred0"><a name="line1270"></a>1270 
</span><span class="marked1"><a name="line1271"></a>1271         def collection_reader_method(reflection, association_proxy_class)
</span><span class="marked0"><a name="line1272"></a>1272           define_method(reflection.name) do |*params|
</span><span class="uncovered1"><a name="line1273"></a>1273             force_reload = params.first unless params.empty?
</span><span class="uncovered0"><a name="line1274"></a>1274             association = association_instance_get(reflection.name)
</span><span class="uncovered1"><a name="line1275"></a>1275 
</span><span class="uncovered0"><a name="line1276"></a>1276             unless association
</span><span class="uncovered1"><a name="line1277"></a>1277               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered0"><a name="line1278"></a>1278               association_instance_set(reflection.name, association)
</span><span class="uncovered1"><a name="line1279"></a>1279             end
</span><span class="uncovered0"><a name="line1280"></a>1280 
</span><span class="uncovered1"><a name="line1281"></a>1281             association.reload if force_reload
</span><span class="uncovered0"><a name="line1282"></a>1282 
</span><span class="uncovered1"><a name="line1283"></a>1283             association
</span><span class="uncovered0"><a name="line1284"></a>1284           end
</span><span class="inferred1"><a name="line1285"></a>1285 
</span><span class="marked0"><a name="line1286"></a>1286           define_method(&quot;#{reflection.name.to_s.singularize}_ids&quot;) do
</span><span class="uncovered1"><a name="line1287"></a>1287             if send(reflection.name).loaded? || reflection.options[:finder_sql]
</span><span class="uncovered0"><a name="line1288"></a>1288               send(reflection.name).map(&amp;:id)
</span><span class="uncovered1"><a name="line1289"></a>1289             else
</span><span class="uncovered0"><a name="line1290"></a>1290               send(reflection.name).all(:select =&gt; &quot;#{reflection.quoted_table_name}.#{reflection.klass.primary_key}&quot;).map(&amp;:id)
</span><span class="uncovered1"><a name="line1291"></a>1291             end
</span><span class="uncovered0"><a name="line1292"></a>1292           end
</span><span class="uncovered1"><a name="line1293"></a>1293         end
</span><span class="inferred0"><a name="line1294"></a>1294 
</span><span class="marked1"><a name="line1295"></a>1295         def collection_accessor_methods(reflection, association_proxy_class, writer = true)
</span><span class="marked0"><a name="line1296"></a>1296           collection_reader_method(reflection, association_proxy_class)
</span><span class="inferred1"><a name="line1297"></a>1297 
</span><span class="marked0"><a name="line1298"></a>1298           if writer
</span><span class="marked1"><a name="line1299"></a>1299             define_method(&quot;#{reflection.name}=&quot;) do |new_value|
</span><span class="uncovered0"><a name="line1300"></a>1300               # Loads proxy class instance (defined in collection_reader_method) if not already loaded
</span><span class="uncovered1"><a name="line1301"></a>1301               association = send(reflection.name)
</span><span class="uncovered0"><a name="line1302"></a>1302               association.replace(new_value)
</span><span class="uncovered1"><a name="line1303"></a>1303               association
</span><span class="uncovered0"><a name="line1304"></a>1304             end
</span><span class="inferred1"><a name="line1305"></a>1305 
</span><span class="marked0"><a name="line1306"></a>1306             define_method(&quot;#{reflection.name.to_s.singularize}_ids=&quot;) do |new_value|
</span><span class="uncovered1"><a name="line1307"></a>1307               ids = (new_value || []).reject { |nid| nid.blank? }
</span><span class="uncovered0"><a name="line1308"></a>1308               send(&quot;#{reflection.name}=&quot;, reflection.class_name.constantize.find(ids))
</span><span class="uncovered1"><a name="line1309"></a>1309             end
</span><span class="uncovered0"><a name="line1310"></a>1310           end
</span><span class="uncovered1"><a name="line1311"></a>1311         end
</span><span class="inferred0"><a name="line1312"></a>1312 
</span><span class="marked1"><a name="line1313"></a>1313         def association_constructor_method(constructor, reflection, association_proxy_class)
</span><span class="marked0"><a name="line1314"></a>1314           define_method(&quot;#{constructor}_#{reflection.name}&quot;) do |*params|
</span><span class="uncovered1"><a name="line1315"></a>1315             attributees      = params.first unless params.empty?
</span><span class="uncovered0"><a name="line1316"></a>1316             replace_existing = params[1].nil? ? true : params[1]
</span><span class="uncovered1"><a name="line1317"></a>1317             association      = association_instance_get(reflection.name)
</span><span class="uncovered0"><a name="line1318"></a>1318 
</span><span class="uncovered1"><a name="line1319"></a>1319             unless association
</span><span class="uncovered0"><a name="line1320"></a>1320               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered1"><a name="line1321"></a>1321               association_instance_set(reflection.name, association)
</span><span class="uncovered0"><a name="line1322"></a>1322             end
</span><span class="uncovered1"><a name="line1323"></a>1323 
</span><span class="uncovered0"><a name="line1324"></a>1324             if association_proxy_class == HasOneAssociation
</span><span class="uncovered1"><a name="line1325"></a>1325               association.send(constructor, attributees, replace_existing)
</span><span class="uncovered0"><a name="line1326"></a>1326             else
</span><span class="uncovered1"><a name="line1327"></a>1327               association.send(constructor, attributees)
</span><span class="uncovered0"><a name="line1328"></a>1328             end
</span><span class="uncovered1"><a name="line1329"></a>1329           end
</span><span class="marked0"><a name="line1330"></a>1330         end
</span><span class="inferred1"><a name="line1331"></a>1331 
</span><span class="marked0"><a name="line1332"></a>1332         def find_with_associations(options = {})
</span><span class="uncovered1"><a name="line1333"></a>1333           catch :invalid_query do
</span><span class="uncovered0"><a name="line1334"></a>1334             join_dependency = JoinDependency.new(self, merge_includes(scope(:find, :include), options[:include]), options[:joins])
</span><span class="uncovered1"><a name="line1335"></a>1335             rows = select_all_rows(options, join_dependency)
</span><span class="uncovered0"><a name="line1336"></a>1336             return join_dependency.instantiate(rows)
</span><span class="uncovered1"><a name="line1337"></a>1337           end
</span><span class="uncovered0"><a name="line1338"></a>1338           []
</span><span class="uncovered1"><a name="line1339"></a>1339         end
</span><span class="inferred0"><a name="line1340"></a>1340 
</span><span class="inferred1"><a name="line1341"></a>1341         # Creates before_destroy callback methods that nullify, delete or destroy
</span><span class="inferred0"><a name="line1342"></a>1342         # has_many associated objects, according to the defined :dependent rule.
</span><span class="inferred1"><a name="line1343"></a>1343         #
</span><span class="inferred0"><a name="line1344"></a>1344         # See HasManyAssociation#delete_records.  Dependent associations
</span><span class="inferred1"><a name="line1345"></a>1345         # delete children, otherwise foreign key is set to NULL.
</span><span class="inferred0"><a name="line1346"></a>1346         #
</span><span class="inferred1"><a name="line1347"></a>1347         # The +extra_conditions+ parameter, which is not used within the main
</span><span class="inferred0"><a name="line1348"></a>1348         # Active Record codebase, is meant to allow plugins to define extra
</span><span class="inferred1"><a name="line1349"></a>1349         # finder conditions.
</span><span class="marked0"><a name="line1350"></a>1350         def configure_dependency_for_has_many(reflection, extra_conditions = nil)
</span><span class="marked1"><a name="line1351"></a>1351           if reflection.options.include?(:dependent)
</span><span class="uncovered0"><a name="line1352"></a>1352             # Add polymorphic type if the :as option is present
</span><span class="uncovered1"><a name="line1353"></a>1353             dependent_conditions = []
</span><span class="uncovered0"><a name="line1354"></a>1354             dependent_conditions &lt;&lt; &quot;#{reflection.primary_key_name} = \#{record.quoted_id}&quot;
</span><span class="uncovered1"><a name="line1355"></a>1355             dependent_conditions &lt;&lt; &quot;#{reflection.options[:as]}_type = '#{base_class.name}'&quot; if reflection.options[:as]
</span><span class="uncovered0"><a name="line1356"></a>1356             dependent_conditions &lt;&lt; sanitize_sql(reflection.options[:conditions]) if reflection.options[:conditions]
</span><span class="uncovered1"><a name="line1357"></a>1357             dependent_conditions &lt;&lt; extra_conditions if extra_conditions
</span><span class="uncovered0"><a name="line1358"></a>1358             dependent_conditions = dependent_conditions.collect {|where| &quot;(#{where})&quot; }.join(&quot; AND &quot;)
</span><span class="uncovered1"><a name="line1359"></a>1359             dependent_conditions = dependent_conditions.gsub('@', '\@')
</span><span class="uncovered0"><a name="line1360"></a>1360             case reflection.options[:dependent]
</span><span class="uncovered1"><a name="line1361"></a>1361               when :destroy
</span><span class="uncovered0"><a name="line1362"></a>1362                 method_name = &quot;has_many_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1363"></a>1363                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1364"></a>1364                   send(reflection.name).each { |o| o.destroy }
</span><span class="uncovered1"><a name="line1365"></a>1365                 end
</span><span class="uncovered0"><a name="line1366"></a>1366                 before_destroy method_name
</span><span class="uncovered1"><a name="line1367"></a>1367               when :delete_all
</span><span class="uncovered0"><a name="line1368"></a>1368                 module_eval %Q{
</span><span class="uncovered1"><a name="line1369"></a>1369                   before_destroy do |record|                  # before_destroy do |record|
</span><span class="uncovered0"><a name="line1370"></a>1370                     delete_all_has_many_dependencies(record,  #   delete_all_has_many_dependencies(record,
</span><span class="uncovered1"><a name="line1371"></a>1371                       &quot;#{reflection.name}&quot;,                   #     &quot;posts&quot;,
</span><span class="uncovered0"><a name="line1372"></a>1372                       #{reflection.class_name},               #     Post,
</span><span class="uncovered1"><a name="line1373"></a>1373                       %@#{dependent_conditions}@)             #     %@...@) # this is a string literal like %(...)
</span><span class="uncovered0"><a name="line1374"></a>1374                   end                                         # end
</span><span class="uncovered1"><a name="line1375"></a>1375                 }
</span><span class="uncovered0"><a name="line1376"></a>1376               when :nullify
</span><span class="uncovered1"><a name="line1377"></a>1377                 module_eval %Q{
</span><span class="uncovered0"><a name="line1378"></a>1378                   before_destroy do |record|                  # before_destroy do |record|
</span><span class="uncovered1"><a name="line1379"></a>1379                     nullify_has_many_dependencies(record,     #   nullify_has_many_dependencies(record,
</span><span class="uncovered0"><a name="line1380"></a>1380                       &quot;#{reflection.name}&quot;,                   #     &quot;posts&quot;,
</span><span class="uncovered1"><a name="line1381"></a>1381                       #{reflection.class_name},               #     Post,
</span><span class="uncovered0"><a name="line1382"></a>1382                       &quot;#{reflection.primary_key_name}&quot;,       #     &quot;user_id&quot;,
</span><span class="uncovered1"><a name="line1383"></a>1383                       %@#{dependent_conditions}@)             #     %@...@) # this is a string literal like %(...)
</span><span class="uncovered0"><a name="line1384"></a>1384                   end                                         # end
</span><span class="uncovered1"><a name="line1385"></a>1385                 }
</span><span class="uncovered0"><a name="line1386"></a>1386               else
</span><span class="uncovered1"><a name="line1387"></a>1387                 raise ArgumentError, &quot;The :dependent option expects either :destroy, :delete_all, or :nullify (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered0"><a name="line1388"></a>1388             end
</span><span class="uncovered1"><a name="line1389"></a>1389           end
</span><span class="marked0"><a name="line1390"></a>1390         end
</span><span class="inferred1"><a name="line1391"></a>1391 
</span><span class="inferred0"><a name="line1392"></a>1392         # Creates before_destroy callback methods that nullify, delete or destroy
</span><span class="inferred1"><a name="line1393"></a>1393         # has_one associated objects, according to the defined :dependent rule.
</span><span class="marked0"><a name="line1394"></a>1394         def configure_dependency_for_has_one(reflection)
</span><span class="marked1"><a name="line1395"></a>1395           if reflection.options.include?(:dependent)
</span><span class="uncovered0"><a name="line1396"></a>1396             case reflection.options[:dependent]
</span><span class="uncovered1"><a name="line1397"></a>1397               when :destroy
</span><span class="uncovered0"><a name="line1398"></a>1398                 method_name = &quot;has_one_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1399"></a>1399                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1400"></a>1400                   association = send(reflection.name)
</span><span class="uncovered1"><a name="line1401"></a>1401                   association.destroy unless association.nil?
</span><span class="uncovered0"><a name="line1402"></a>1402                 end
</span><span class="uncovered1"><a name="line1403"></a>1403                 before_destroy method_name
</span><span class="uncovered0"><a name="line1404"></a>1404               when :delete
</span><span class="uncovered1"><a name="line1405"></a>1405                 method_name = &quot;has_one_dependent_delete_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1406"></a>1406                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1407"></a>1407                   # Retrieve the associated object and delete it. The retrieval
</span><span class="uncovered0"><a name="line1408"></a>1408                   # is necessary because there may be multiple associated objects
</span><span class="uncovered1"><a name="line1409"></a>1409                   # with foreign keys pointing to this object, and we only want
</span><span class="uncovered0"><a name="line1410"></a>1410                   # to delete the correct one, not all of them.
</span><span class="uncovered1"><a name="line1411"></a>1411                   association = send(reflection.name)
</span><span class="uncovered0"><a name="line1412"></a>1412                   association.delete unless association.nil?
</span><span class="uncovered1"><a name="line1413"></a>1413                 end
</span><span class="uncovered0"><a name="line1414"></a>1414                 before_destroy method_name
</span><span class="uncovered1"><a name="line1415"></a>1415               when :nullify
</span><span class="uncovered0"><a name="line1416"></a>1416                 method_name = &quot;has_one_dependent_nullify_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1417"></a>1417                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1418"></a>1418                   association = send(reflection.name)
</span><span class="uncovered1"><a name="line1419"></a>1419                   association.update_attribute(reflection.primary_key_name, nil) unless association.nil?
</span><span class="uncovered0"><a name="line1420"></a>1420                 end
</span><span class="uncovered1"><a name="line1421"></a>1421                 before_destroy method_name
</span><span class="uncovered0"><a name="line1422"></a>1422               else
</span><span class="uncovered1"><a name="line1423"></a>1423                 raise ArgumentError, &quot;The :dependent option expects either :destroy, :delete or :nullify (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered0"><a name="line1424"></a>1424             end
</span><span class="uncovered1"><a name="line1425"></a>1425           end
</span><span class="marked0"><a name="line1426"></a>1426         end
</span><span class="inferred1"><a name="line1427"></a>1427 
</span><span class="marked0"><a name="line1428"></a>1428         def configure_dependency_for_belongs_to(reflection)
</span><span class="marked1"><a name="line1429"></a>1429           if reflection.options.include?(:dependent)
</span><span class="uncovered0"><a name="line1430"></a>1430             case reflection.options[:dependent]
</span><span class="uncovered1"><a name="line1431"></a>1431               when :destroy
</span><span class="uncovered0"><a name="line1432"></a>1432                 method_name = &quot;belongs_to_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1433"></a>1433                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1434"></a>1434                   association = send(reflection.name)
</span><span class="uncovered1"><a name="line1435"></a>1435                   association.destroy unless association.nil?
</span><span class="uncovered0"><a name="line1436"></a>1436                 end
</span><span class="uncovered1"><a name="line1437"></a>1437                 after_destroy method_name
</span><span class="uncovered0"><a name="line1438"></a>1438               when :delete
</span><span class="uncovered1"><a name="line1439"></a>1439                 method_name = &quot;belongs_to_dependent_delete_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1440"></a>1440                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1441"></a>1441                   association = send(reflection.name)
</span><span class="uncovered0"><a name="line1442"></a>1442                   association.delete unless association.nil?
</span><span class="uncovered1"><a name="line1443"></a>1443                 end
</span><span class="uncovered0"><a name="line1444"></a>1444                 after_destroy method_name
</span><span class="uncovered1"><a name="line1445"></a>1445               else
</span><span class="uncovered0"><a name="line1446"></a>1446                 raise ArgumentError, &quot;The :dependent option expects either :destroy or :delete (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered1"><a name="line1447"></a>1447             end
</span><span class="uncovered0"><a name="line1448"></a>1448           end
</span><span class="marked1"><a name="line1449"></a>1449         end
</span><span class="inferred0"><a name="line1450"></a>1450 
</span><span class="marked1"><a name="line1451"></a>1451         def delete_all_has_many_dependencies(record, reflection_name, association_class, dependent_conditions)
</span><span class="uncovered0"><a name="line1452"></a>1452           association_class.delete_all(dependent_conditions)
</span><span class="uncovered1"><a name="line1453"></a>1453         end
</span><span class="inferred0"><a name="line1454"></a>1454 
</span><span class="marked1"><a name="line1455"></a>1455         def nullify_has_many_dependencies(record, reflection_name, association_class, primary_key_name, dependent_conditions)
</span><span class="uncovered0"><a name="line1456"></a>1456           association_class.update_all(&quot;#{primary_key_name} = NULL&quot;, dependent_conditions)
</span><span class="uncovered1"><a name="line1457"></a>1457         end
</span><span class="inferred0"><a name="line1458"></a>1458 
</span><span class="marked1"><a name="line1459"></a>1459         mattr_accessor :valid_keys_for_has_many_association
</span><span class="marked0"><a name="line1460"></a>1460         @@valid_keys_for_has_many_association = [
</span><span class="inferred1"><a name="line1461"></a>1461           :class_name, :table_name, :foreign_key, :primary_key,
</span><span class="inferred0"><a name="line1462"></a>1462           :dependent,
</span><span class="inferred1"><a name="line1463"></a>1463           :select, :conditions, :include, :order, :group, :having, :limit, :offset,
</span><span class="inferred0"><a name="line1464"></a>1464           :as, :through, :source, :source_type,
</span><span class="inferred1"><a name="line1465"></a>1465           :uniq,
</span><span class="inferred0"><a name="line1466"></a>1466           :finder_sql, :counter_sql,
</span><span class="inferred1"><a name="line1467"></a>1467           :before_add, :after_add, :before_remove, :after_remove,
</span><span class="inferred0"><a name="line1468"></a>1468           :extend, :readonly,
</span><span class="inferred1"><a name="line1469"></a>1469           :validate
</span><span class="inferred0"><a name="line1470"></a>1470         ]
</span><span class="inferred1"><a name="line1471"></a>1471 
</span><span class="marked0"><a name="line1472"></a>1472         def create_has_many_reflection(association_id, options, &amp;extension)
</span><span class="marked1"><a name="line1473"></a>1473           options.assert_valid_keys(valid_keys_for_has_many_association)
</span><span class="marked0"><a name="line1474"></a>1474           options[:extend] = create_extension_modules(association_id, extension, options[:extend])
</span><span class="inferred1"><a name="line1475"></a>1475 
</span><span class="marked0"><a name="line1476"></a>1476           create_reflection(:has_many, association_id, options, self)
</span><span class="inferred1"><a name="line1477"></a>1477         end
</span><span class="inferred0"><a name="line1478"></a>1478 
</span><span class="marked1"><a name="line1479"></a>1479         mattr_accessor :valid_keys_for_has_one_association
</span><span class="marked0"><a name="line1480"></a>1480         @@valid_keys_for_has_one_association = [
</span><span class="inferred1"><a name="line1481"></a>1481           :class_name, :foreign_key, :remote, :select, :conditions, :order,
</span><span class="inferred0"><a name="line1482"></a>1482           :include, :dependent, :counter_cache, :extend, :as, :readonly,
</span><span class="inferred1"><a name="line1483"></a>1483           :validate, :primary_key
</span><span class="inferred0"><a name="line1484"></a>1484         ]
</span><span class="inferred1"><a name="line1485"></a>1485 
</span><span class="marked0"><a name="line1486"></a>1486         def create_has_one_reflection(association_id, options)
</span><span class="marked1"><a name="line1487"></a>1487           options.assert_valid_keys(valid_keys_for_has_one_association)
</span><span class="marked0"><a name="line1488"></a>1488           create_reflection(:has_one, association_id, options, self)
</span><span class="inferred1"><a name="line1489"></a>1489         end
</span><span class="inferred0"><a name="line1490"></a>1490 
</span><span class="marked1"><a name="line1491"></a>1491         def create_has_one_through_reflection(association_id, options)
</span><span class="uncovered0"><a name="line1492"></a>1492           options.assert_valid_keys(
</span><span class="uncovered1"><a name="line1493"></a>1493             :class_name, :foreign_key, :remote, :select, :conditions, :order, :include, :dependent, :counter_cache, :extend, :as, :through, :source, :source_type, :validate
</span><span class="uncovered0"><a name="line1494"></a>1494           )
</span><span class="uncovered1"><a name="line1495"></a>1495           create_reflection(:has_one, association_id, options, self)
</span><span class="uncovered0"><a name="line1496"></a>1496         end
</span><span class="inferred1"><a name="line1497"></a>1497 
</span><span class="marked0"><a name="line1498"></a>1498         mattr_accessor :valid_keys_for_belongs_to_association
</span><span class="marked1"><a name="line1499"></a>1499         @@valid_keys_for_belongs_to_association = [
</span><span class="inferred0"><a name="line1500"></a>1500           :class_name, :foreign_key, :foreign_type, :remote, :select, :conditions,
</span><span class="inferred1"><a name="line1501"></a>1501           :include, :dependent, :counter_cache, :extend, :polymorphic, :readonly,
</span><span class="inferred0"><a name="line1502"></a>1502           :validate
</span><span class="inferred1"><a name="line1503"></a>1503         ]
</span><span class="inferred0"><a name="line1504"></a>1504 
</span><span class="marked1"><a name="line1505"></a>1505         def create_belongs_to_reflection(association_id, options)
</span><span class="marked0"><a name="line1506"></a>1506           options.assert_valid_keys(valid_keys_for_belongs_to_association)
</span><span class="marked1"><a name="line1507"></a>1507           reflection = create_reflection(:belongs_to, association_id, options, self)
</span><span class="inferred0"><a name="line1508"></a>1508 
</span><span class="marked1"><a name="line1509"></a>1509           if options[:polymorphic]
</span><span class="uncovered0"><a name="line1510"></a>1510             reflection.options[:foreign_type] ||= reflection.class_name.underscore + &quot;_type&quot;
</span><span class="uncovered1"><a name="line1511"></a>1511           end
</span><span class="inferred0"><a name="line1512"></a>1512 
</span><span class="marked1"><a name="line1513"></a>1513           reflection
</span><span class="inferred0"><a name="line1514"></a>1514         end
</span><span class="inferred1"><a name="line1515"></a>1515 
</span><span class="marked0"><a name="line1516"></a>1516         mattr_accessor :valid_keys_for_has_and_belongs_to_many_association
</span><span class="marked1"><a name="line1517"></a>1517         @@valid_keys_for_has_and_belongs_to_many_association = [
</span><span class="inferred0"><a name="line1518"></a>1518           :class_name, :table_name, :join_table, :foreign_key, :association_foreign_key,
</span><span class="inferred1"><a name="line1519"></a>1519           :select, :conditions, :include, :order, :group, :having, :limit, :offset,
</span><span class="inferred0"><a name="line1520"></a>1520           :uniq,
</span><span class="inferred1"><a name="line1521"></a>1521           :finder_sql, :counter_sql, :delete_sql, :insert_sql,
</span><span class="inferred0"><a name="line1522"></a>1522           :before_add, :after_add, :before_remove, :after_remove,
</span><span class="inferred1"><a name="line1523"></a>1523           :extend, :readonly,
</span><span class="inferred0"><a name="line1524"></a>1524           :validate
</span><span class="inferred1"><a name="line1525"></a>1525         ]
</span><span class="inferred0"><a name="line1526"></a>1526 
</span><span class="marked1"><a name="line1527"></a>1527         def create_has_and_belongs_to_many_reflection(association_id, options, &amp;extension)
</span><span class="uncovered0"><a name="line1528"></a>1528           options.assert_valid_keys(valid_keys_for_has_and_belongs_to_many_association)
</span><span class="uncovered1"><a name="line1529"></a>1529 
</span><span class="uncovered0"><a name="line1530"></a>1530           options[:extend] = create_extension_modules(association_id, extension, options[:extend])
</span><span class="uncovered1"><a name="line1531"></a>1531 
</span><span class="uncovered0"><a name="line1532"></a>1532           reflection = create_reflection(:has_and_belongs_to_many, association_id, options, self)
</span><span class="uncovered1"><a name="line1533"></a>1533           
</span><span class="uncovered0"><a name="line1534"></a>1534           if reflection.association_foreign_key == reflection.primary_key_name
</span><span class="uncovered1"><a name="line1535"></a>1535             raise HasAndBelongsToManyAssociationForeignKeyNeeded.new(reflection)
</span><span class="uncovered0"><a name="line1536"></a>1536           end
</span><span class="uncovered1"><a name="line1537"></a>1537 
</span><span class="uncovered0"><a name="line1538"></a>1538           reflection.options[:join_table] ||= join_table_name(undecorated_table_name(self.to_s), undecorated_table_name(reflection.class_name))
</span><span class="uncovered1"><a name="line1539"></a>1539 
</span><span class="uncovered0"><a name="line1540"></a>1540           reflection
</span><span class="uncovered1"><a name="line1541"></a>1541         end
</span><span class="inferred0"><a name="line1542"></a>1542 
</span><span class="marked1"><a name="line1543"></a>1543         def reflect_on_included_associations(associations)
</span><span class="uncovered0"><a name="line1544"></a>1544           [ associations ].flatten.collect { |association| reflect_on_association(association.to_s.intern) }
</span><span class="uncovered1"><a name="line1545"></a>1545         end
</span><span class="inferred0"><a name="line1546"></a>1546 
</span><span class="marked1"><a name="line1547"></a>1547         def guard_against_unlimitable_reflections(reflections, options)
</span><span class="uncovered0"><a name="line1548"></a>1548           if (options[:offset] || options[:limit]) &amp;&amp; !using_limitable_reflections?(reflections)
</span><span class="uncovered1"><a name="line1549"></a>1549             raise(
</span><span class="uncovered0"><a name="line1550"></a>1550               ConfigurationError,
</span><span class="uncovered1"><a name="line1551"></a>1551               &quot;You can not use offset and limit together with has_many or has_and_belongs_to_many associations&quot;
</span><span class="uncovered0"><a name="line1552"></a>1552             )
</span><span class="uncovered1"><a name="line1553"></a>1553           end
</span><span class="uncovered0"><a name="line1554"></a>1554         end
</span><span class="inferred1"><a name="line1555"></a>1555 
</span><span class="marked0"><a name="line1556"></a>1556         def select_all_rows(options, join_dependency)
</span><span class="uncovered1"><a name="line1557"></a>1557           connection.select_all(
</span><span class="uncovered0"><a name="line1558"></a>1558             construct_finder_sql_with_included_associations(options, join_dependency),
</span><span class="uncovered1"><a name="line1559"></a>1559             &quot;#{name} Load Including Associations&quot;
</span><span class="uncovered0"><a name="line1560"></a>1560           )
</span><span class="uncovered1"><a name="line1561"></a>1561         end
</span><span class="inferred0"><a name="line1562"></a>1562 
</span><span class="marked1"><a name="line1563"></a>1563         def construct_finder_sql_with_included_associations(options, join_dependency)
</span><span class="uncovered0"><a name="line1564"></a>1564           scope = scope(:find)
</span><span class="uncovered1"><a name="line1565"></a>1565           sql = &quot;SELECT #{column_aliases(join_dependency)} FROM #{(scope &amp;&amp; scope[:from]) || options[:from] || quoted_table_name} &quot;
</span><span class="uncovered0"><a name="line1566"></a>1566           sql &lt;&lt; join_dependency.join_associations.collect{|join| join.association_join }.join
</span><span class="uncovered1"><a name="line1567"></a>1567 
</span><span class="uncovered0"><a name="line1568"></a>1568           add_joins!(sql, options[:joins], scope)
</span><span class="uncovered1"><a name="line1569"></a>1569           add_conditions!(sql, options[:conditions], scope)
</span><span class="uncovered0"><a name="line1570"></a>1570           add_limited_ids_condition!(sql, options, join_dependency) if !using_limitable_reflections?(join_dependency.reflections) &amp;&amp; ((scope &amp;&amp; scope[:limit]) || options[:limit])
</span><span class="uncovered1"><a name="line1571"></a>1571 
</span><span class="uncovered0"><a name="line1572"></a>1572           add_group!(sql, options[:group], options[:having], scope)
</span><span class="uncovered1"><a name="line1573"></a>1573           add_order!(sql, options[:order], scope)
</span><span class="uncovered0"><a name="line1574"></a>1574           add_limit!(sql, options, scope) if using_limitable_reflections?(join_dependency.reflections)
</span><span class="uncovered1"><a name="line1575"></a>1575           add_lock!(sql, options, scope)
</span><span class="uncovered0"><a name="line1576"></a>1576 
</span><span class="uncovered1"><a name="line1577"></a>1577           return sanitize_sql(sql)
</span><span class="uncovered0"><a name="line1578"></a>1578         end
</span><span class="inferred1"><a name="line1579"></a>1579 
</span><span class="marked0"><a name="line1580"></a>1580         def add_limited_ids_condition!(sql, options, join_dependency)
</span><span class="uncovered1"><a name="line1581"></a>1581           unless (id_list = select_limited_ids_list(options, join_dependency)).empty?
</span><span class="uncovered0"><a name="line1582"></a>1582             sql &lt;&lt; &quot;#{condition_word(sql)} #{connection.quote_table_name table_name}.#{primary_key} IN (#{id_list}) &quot;
</span><span class="uncovered1"><a name="line1583"></a>1583           else
</span><span class="uncovered0"><a name="line1584"></a>1584             throw :invalid_query
</span><span class="uncovered1"><a name="line1585"></a>1585           end
</span><span class="uncovered0"><a name="line1586"></a>1586         end
</span><span class="inferred1"><a name="line1587"></a>1587 
</span><span class="marked0"><a name="line1588"></a>1588         def select_limited_ids_list(options, join_dependency)
</span><span class="uncovered1"><a name="line1589"></a>1589           pk = columns_hash[primary_key]
</span><span class="uncovered0"><a name="line1590"></a>1590 
</span><span class="uncovered1"><a name="line1591"></a>1591           connection.select_all(
</span><span class="uncovered0"><a name="line1592"></a>1592             construct_finder_sql_for_association_limiting(options, join_dependency),
</span><span class="uncovered1"><a name="line1593"></a>1593             &quot;#{name} Load IDs For Limited Eager Loading&quot;
</span><span class="uncovered0"><a name="line1594"></a>1594           ).collect { |row| connection.quote(row[primary_key], pk) }.join(&quot;, &quot;)
</span><span class="uncovered1"><a name="line1595"></a>1595         end
</span><span class="inferred0"><a name="line1596"></a>1596 
</span><span class="marked1"><a name="line1597"></a>1597         def construct_finder_sql_for_association_limiting(options, join_dependency)
</span><span class="uncovered0"><a name="line1598"></a>1598           scope       = scope(:find)
</span><span class="uncovered1"><a name="line1599"></a>1599 
</span><span class="uncovered0"><a name="line1600"></a>1600           # Only join tables referenced in order or conditions since this is particularly slow on the pre-query.
</span><span class="uncovered1"><a name="line1601"></a>1601           tables_from_conditions = conditions_tables(options)
</span><span class="uncovered0"><a name="line1602"></a>1602           tables_from_order      = order_tables(options)
</span><span class="uncovered1"><a name="line1603"></a>1603           all_tables             = tables_from_conditions + tables_from_order
</span><span class="uncovered0"><a name="line1604"></a>1604           distinct_join_associations = all_tables.uniq.map{|table|
</span><span class="uncovered1"><a name="line1605"></a>1605             join_dependency.joins_for_table_name(table)
</span><span class="uncovered0"><a name="line1606"></a>1606           }.flatten.compact.uniq
</span><span class="uncovered1"><a name="line1607"></a>1607 
</span><span class="uncovered0"><a name="line1608"></a>1608           order = options[:order]
</span><span class="uncovered1"><a name="line1609"></a>1609           if scoped_order = (scope &amp;&amp; scope[:order])
</span><span class="uncovered0"><a name="line1610"></a>1610             order = order ? &quot;#{order}, #{scoped_order}&quot; : scoped_order
</span><span class="uncovered1"><a name="line1611"></a>1611           end
</span><span class="uncovered0"><a name="line1612"></a>1612 
</span><span class="uncovered1"><a name="line1613"></a>1613           is_distinct = !options[:joins].blank? || include_eager_conditions?(options, tables_from_conditions) || include_eager_order?(options, tables_from_order)
</span><span class="uncovered0"><a name="line1614"></a>1614           sql = &quot;SELECT &quot;
</span><span class="uncovered1"><a name="line1615"></a>1615           if is_distinct
</span><span class="uncovered0"><a name="line1616"></a>1616             sql &lt;&lt; connection.distinct(&quot;#{connection.quote_table_name table_name}.#{primary_key}&quot;, order)
</span><span class="uncovered1"><a name="line1617"></a>1617           else
</span><span class="uncovered0"><a name="line1618"></a>1618             sql &lt;&lt; primary_key
</span><span class="uncovered1"><a name="line1619"></a>1619           end
</span><span class="uncovered0"><a name="line1620"></a>1620           sql &lt;&lt; &quot; FROM #{connection.quote_table_name table_name} &quot;
</span><span class="uncovered1"><a name="line1621"></a>1621 
</span><span class="uncovered0"><a name="line1622"></a>1622           if is_distinct
</span><span class="uncovered1"><a name="line1623"></a>1623             sql &lt;&lt; distinct_join_associations.collect { |assoc| assoc.association_join }.join
</span><span class="uncovered0"><a name="line1624"></a>1624             add_joins!(sql, options[:joins], scope)
</span><span class="uncovered1"><a name="line1625"></a>1625           end
</span><span class="uncovered0"><a name="line1626"></a>1626 
</span><span class="uncovered1"><a name="line1627"></a>1627           add_conditions!(sql, options[:conditions], scope)
</span><span class="uncovered0"><a name="line1628"></a>1628           add_group!(sql, options[:group], options[:having], scope)
</span><span class="uncovered1"><a name="line1629"></a>1629 
</span><span class="uncovered0"><a name="line1630"></a>1630           if order &amp;&amp; is_distinct
</span><span class="uncovered1"><a name="line1631"></a>1631             connection.add_order_by_for_association_limiting!(sql, :order =&gt; order)
</span><span class="uncovered0"><a name="line1632"></a>1632           else
</span><span class="uncovered1"><a name="line1633"></a>1633             add_order!(sql, options[:order], scope)
</span><span class="uncovered0"><a name="line1634"></a>1634           end
</span><span class="uncovered1"><a name="line1635"></a>1635 
</span><span class="uncovered0"><a name="line1636"></a>1636           add_limit!(sql, options, scope)
</span><span class="uncovered1"><a name="line1637"></a>1637 
</span><span class="uncovered0"><a name="line1638"></a>1638           return sanitize_sql(sql)
</span><span class="uncovered1"><a name="line1639"></a>1639         end
</span><span class="inferred0"><a name="line1640"></a>1640 
</span><span class="marked1"><a name="line1641"></a>1641         def tables_in_string(string)
</span><span class="uncovered0"><a name="line1642"></a>1642           return [] if string.blank?
</span><span class="uncovered1"><a name="line1643"></a>1643           string.scan(/([\.a-zA-Z_]+).?\./).flatten
</span><span class="uncovered0"><a name="line1644"></a>1644         end
</span><span class="inferred1"><a name="line1645"></a>1645 
</span><span class="marked0"><a name="line1646"></a>1646         def conditions_tables(options)
</span><span class="uncovered1"><a name="line1647"></a>1647           # look in both sets of conditions
</span><span class="uncovered0"><a name="line1648"></a>1648           conditions = [scope(:find, :conditions), options[:conditions]].inject([]) do |all, cond|
</span><span class="uncovered1"><a name="line1649"></a>1649             case cond
</span><span class="uncovered0"><a name="line1650"></a>1650               when nil   then all
</span><span class="uncovered1"><a name="line1651"></a>1651               when Array then all &lt;&lt; cond.first
</span><span class="uncovered0"><a name="line1652"></a>1652               when Hash  then all &lt;&lt; cond.keys
</span><span class="uncovered1"><a name="line1653"></a>1653               else            all &lt;&lt; cond
</span><span class="uncovered0"><a name="line1654"></a>1654             end
</span><span class="uncovered1"><a name="line1655"></a>1655           end
</span><span class="uncovered0"><a name="line1656"></a>1656           tables_in_string(conditions.join(' '))
</span><span class="uncovered1"><a name="line1657"></a>1657         end
</span><span class="inferred0"><a name="line1658"></a>1658 
</span><span class="marked1"><a name="line1659"></a>1659         def order_tables(options)
</span><span class="uncovered0"><a name="line1660"></a>1660           order = [options[:order], scope(:find, :order) ].join(&quot;, &quot;)
</span><span class="uncovered1"><a name="line1661"></a>1661           return [] unless order &amp;&amp; order.is_a?(String)
</span><span class="uncovered0"><a name="line1662"></a>1662           tables_in_string(order)
</span><span class="uncovered1"><a name="line1663"></a>1663         end
</span><span class="inferred0"><a name="line1664"></a>1664 
</span><span class="marked1"><a name="line1665"></a>1665         def selects_tables(options)
</span><span class="uncovered0"><a name="line1666"></a>1666           select = options[:select]
</span><span class="uncovered1"><a name="line1667"></a>1667           return [] unless select &amp;&amp; select.is_a?(String)
</span><span class="uncovered0"><a name="line1668"></a>1668           tables_in_string(select)
</span><span class="uncovered1"><a name="line1669"></a>1669         end
</span><span class="inferred0"><a name="line1670"></a>1670 
</span><span class="marked1"><a name="line1671"></a>1671         def joined_tables(options)
</span><span class="uncovered0"><a name="line1672"></a>1672           scope = scope(:find)
</span><span class="uncovered1"><a name="line1673"></a>1673           joins = options[:joins]
</span><span class="uncovered0"><a name="line1674"></a>1674           merged_joins = scope &amp;&amp; scope[:joins] &amp;&amp; joins ? merge_joins(scope[:joins], joins) : (joins || scope &amp;&amp; scope[:joins])
</span><span class="uncovered1"><a name="line1675"></a>1675           [table_name] + case merged_joins
</span><span class="uncovered0"><a name="line1676"></a>1676           when Symbol, Hash, Array
</span><span class="uncovered1"><a name="line1677"></a>1677             if array_of_strings?(merged_joins)
</span><span class="uncovered0"><a name="line1678"></a>1678               tables_in_string(merged_joins.join(' '))
</span><span class="uncovered1"><a name="line1679"></a>1679             else
</span><span class="uncovered0"><a name="line1680"></a>1680               join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, merged_joins, nil)
</span><span class="uncovered1"><a name="line1681"></a>1681               join_dependency.join_associations.collect {|join_association| [join_association.aliased_join_table_name, join_association.aliased_table_name]}.flatten.compact
</span><span class="uncovered0"><a name="line1682"></a>1682             end
</span><span class="uncovered1"><a name="line1683"></a>1683           else
</span><span class="uncovered0"><a name="line1684"></a>1684             tables_in_string(merged_joins)
</span><span class="uncovered1"><a name="line1685"></a>1685           end
</span><span class="uncovered0"><a name="line1686"></a>1686         end
</span><span class="inferred1"><a name="line1687"></a>1687 
</span><span class="inferred0"><a name="line1688"></a>1688         # Checks if the conditions reference a table other than the current model table
</span><span class="marked1"><a name="line1689"></a>1689         def include_eager_conditions?(options, tables = nil, joined_tables = nil)
</span><span class="uncovered0"><a name="line1690"></a>1690           ((tables || conditions_tables(options)) - (joined_tables || joined_tables(options))).any?
</span><span class="uncovered1"><a name="line1691"></a>1691         end
</span><span class="inferred0"><a name="line1692"></a>1692 
</span><span class="inferred1"><a name="line1693"></a>1693         # Checks if the query order references a table other than the current model's table.
</span><span class="marked0"><a name="line1694"></a>1694         def include_eager_order?(options, tables = nil, joined_tables = nil)
</span><span class="uncovered1"><a name="line1695"></a>1695           ((tables || order_tables(options)) - (joined_tables || joined_tables(options))).any?
</span><span class="uncovered0"><a name="line1696"></a>1696         end
</span><span class="inferred1"><a name="line1697"></a>1697 
</span><span class="marked0"><a name="line1698"></a>1698         def include_eager_select?(options, joined_tables = nil)
</span><span class="uncovered1"><a name="line1699"></a>1699           (selects_tables(options) - (joined_tables || joined_tables(options))).any?
</span><span class="uncovered0"><a name="line1700"></a>1700         end
</span><span class="inferred1"><a name="line1701"></a>1701 
</span><span class="marked0"><a name="line1702"></a>1702         def references_eager_loaded_tables?(options)
</span><span class="uncovered1"><a name="line1703"></a>1703           joined_tables = joined_tables(options)
</span><span class="uncovered0"><a name="line1704"></a>1704           include_eager_order?(options, nil, joined_tables) || include_eager_conditions?(options, nil, joined_tables) || include_eager_select?(options, joined_tables)
</span><span class="uncovered1"><a name="line1705"></a>1705         end
</span><span class="inferred0"><a name="line1706"></a>1706 
</span><span class="marked1"><a name="line1707"></a>1707         def using_limitable_reflections?(reflections)
</span><span class="uncovered0"><a name="line1708"></a>1708           reflections.reject { |r| [ :belongs_to, :has_one ].include?(r.macro) }.length.zero?
</span><span class="uncovered1"><a name="line1709"></a>1709         end
</span><span class="inferred0"><a name="line1710"></a>1710 
</span><span class="marked1"><a name="line1711"></a>1711         def column_aliases(join_dependency)
</span><span class="uncovered0"><a name="line1712"></a>1712           join_dependency.joins.collect{|join| join.column_names_with_alias.collect{|column_name, aliased_name|
</span><span class="uncovered1"><a name="line1713"></a>1713               &quot;#{connection.quote_table_name join.aliased_table_name}.#{connection.quote_column_name column_name} AS #{aliased_name}&quot;}}.flatten.join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line1714"></a>1714         end
</span><span class="inferred1"><a name="line1715"></a>1715 
</span><span class="marked0"><a name="line1716"></a>1716         def add_association_callbacks(association_name, options)
</span><span class="marked1"><a name="line1717"></a>1717           callbacks = %w(before_add after_add before_remove after_remove)
</span><span class="marked0"><a name="line1718"></a>1718           callbacks.each do |callback_name|
</span><span class="marked1"><a name="line1719"></a>1719             full_callback_name = &quot;#{callback_name}_for_#{association_name}&quot;
</span><span class="marked0"><a name="line1720"></a>1720             defined_callbacks = options[callback_name.to_sym]
</span><span class="marked1"><a name="line1721"></a>1721             if options.has_key?(callback_name.to_sym)
</span><span class="inferred0"><a name="line1722"></a>1722               class_inheritable_reader full_callback_name.to_sym
</span><span class="inferred1"><a name="line1723"></a>1723               write_inheritable_attribute(full_callback_name.to_sym, [defined_callbacks].flatten)
</span><span class="inferred0"><a name="line1724"></a>1724             else
</span><span class="marked1"><a name="line1725"></a>1725               write_inheritable_attribute(full_callback_name.to_sym, [])
</span><span class="inferred0"><a name="line1726"></a>1726             end
</span><span class="inferred1"><a name="line1727"></a>1727           end
</span><span class="inferred0"><a name="line1728"></a>1728         end
</span><span class="inferred1"><a name="line1729"></a>1729 
</span><span class="marked0"><a name="line1730"></a>1730         def condition_word(sql)
</span><span class="uncovered1"><a name="line1731"></a>1731           sql =~ /where/i ? &quot; AND &quot; : &quot;WHERE &quot;
</span><span class="uncovered0"><a name="line1732"></a>1732         end
</span><span class="inferred1"><a name="line1733"></a>1733 
</span><span class="marked0"><a name="line1734"></a>1734         def create_extension_modules(association_id, block_extension, extensions)
</span><span class="marked1"><a name="line1735"></a>1735           if block_extension
</span><span class="uncovered0"><a name="line1736"></a>1736             extension_module_name = &quot;#{self.to_s.demodulize}#{association_id.to_s.camelize}AssociationExtension&quot;
</span><span class="uncovered1"><a name="line1737"></a>1737 
</span><span class="uncovered0"><a name="line1738"></a>1738             silence_warnings do
</span><span class="uncovered1"><a name="line1739"></a>1739               self.parent.const_set(extension_module_name, Module.new(&amp;block_extension))
</span><span class="uncovered0"><a name="line1740"></a>1740             end
</span><span class="uncovered1"><a name="line1741"></a>1741             Array(extensions).push(&quot;#{self.parent}::#{extension_module_name}&quot;.constantize)
</span><span class="inferred0"><a name="line1742"></a>1742           else
</span><span class="marked1"><a name="line1743"></a>1743             Array(extensions)
</span><span class="inferred0"><a name="line1744"></a>1744           end
</span><span class="marked1"><a name="line1745"></a>1745         end
</span><span class="inferred0"><a name="line1746"></a>1746 
</span><span class="marked1"><a name="line1747"></a>1747         class JoinDependency # :nodoc:
</span><span class="marked0"><a name="line1748"></a>1748           attr_reader :joins, :reflections, :table_aliases
</span><span class="inferred1"><a name="line1749"></a>1749 
</span><span class="marked0"><a name="line1750"></a>1750           def initialize(base, associations, joins)
</span><span class="uncovered1"><a name="line1751"></a>1751             @joins                 = [JoinBase.new(base, joins)]
</span><span class="uncovered0"><a name="line1752"></a>1752             @associations          = associations
</span><span class="uncovered1"><a name="line1753"></a>1753             @reflections           = []
</span><span class="uncovered0"><a name="line1754"></a>1754             @base_records_hash     = {}
</span><span class="uncovered1"><a name="line1755"></a>1755             @base_records_in_order = []
</span><span class="uncovered0"><a name="line1756"></a>1756             @table_aliases         = Hash.new { |aliases, table| aliases[table] = 0 }
</span><span class="uncovered1"><a name="line1757"></a>1757             @table_aliases[base.table_name] = 1
</span><span class="uncovered0"><a name="line1758"></a>1758             build(associations)
</span><span class="uncovered1"><a name="line1759"></a>1759           end
</span><span class="inferred0"><a name="line1760"></a>1760 
</span><span class="marked1"><a name="line1761"></a>1761           def join_associations
</span><span class="uncovered0"><a name="line1762"></a>1762             @joins[1..-1].to_a
</span><span class="uncovered1"><a name="line1763"></a>1763           end
</span><span class="inferred0"><a name="line1764"></a>1764 
</span><span class="marked1"><a name="line1765"></a>1765           def join_base
</span><span class="uncovered0"><a name="line1766"></a>1766             @joins[0]
</span><span class="uncovered1"><a name="line1767"></a>1767           end
</span><span class="inferred0"><a name="line1768"></a>1768 
</span><span class="marked1"><a name="line1769"></a>1769           def instantiate(rows)
</span><span class="uncovered0"><a name="line1770"></a>1770             rows.each_with_index do |row, i|
</span><span class="uncovered1"><a name="line1771"></a>1771               primary_id = join_base.record_id(row)
</span><span class="uncovered0"><a name="line1772"></a>1772               unless @base_records_hash[primary_id]
</span><span class="uncovered1"><a name="line1773"></a>1773                 @base_records_in_order &lt;&lt; (@base_records_hash[primary_id] = join_base.instantiate(row))
</span><span class="uncovered0"><a name="line1774"></a>1774               end
</span><span class="uncovered1"><a name="line1775"></a>1775               construct(@base_records_hash[primary_id], @associations, join_associations.dup, row)
</span><span class="uncovered0"><a name="line1776"></a>1776             end
</span><span class="uncovered1"><a name="line1777"></a>1777             remove_duplicate_results!(join_base.active_record, @base_records_in_order, @associations)
</span><span class="uncovered0"><a name="line1778"></a>1778             return @base_records_in_order
</span><span class="uncovered1"><a name="line1779"></a>1779           end
</span><span class="inferred0"><a name="line1780"></a>1780 
</span><span class="marked1"><a name="line1781"></a>1781           def remove_duplicate_results!(base, records, associations)
</span><span class="uncovered0"><a name="line1782"></a>1782             case associations
</span><span class="uncovered1"><a name="line1783"></a>1783               when Symbol, String
</span><span class="uncovered0"><a name="line1784"></a>1784                 reflection = base.reflections[associations]
</span><span class="uncovered1"><a name="line1785"></a>1785                 if reflection &amp;&amp; [:has_many, :has_and_belongs_to_many].include?(reflection.macro)
</span><span class="uncovered0"><a name="line1786"></a>1786                   records.each { |record| record.send(reflection.name).target.uniq! }
</span><span class="uncovered1"><a name="line1787"></a>1787                 end
</span><span class="uncovered0"><a name="line1788"></a>1788               when Array
</span><span class="uncovered1"><a name="line1789"></a>1789                 associations.each do |association|
</span><span class="uncovered0"><a name="line1790"></a>1790                   remove_duplicate_results!(base, records, association)
</span><span class="uncovered1"><a name="line1791"></a>1791                 end
</span><span class="uncovered0"><a name="line1792"></a>1792               when Hash
</span><span class="uncovered1"><a name="line1793"></a>1793                 associations.keys.each do |name|
</span><span class="uncovered0"><a name="line1794"></a>1794                   reflection = base.reflections[name]
</span><span class="uncovered1"><a name="line1795"></a>1795                   is_collection = [:has_many, :has_and_belongs_to_many].include?(reflection.macro)
</span><span class="uncovered0"><a name="line1796"></a>1796 
</span><span class="uncovered1"><a name="line1797"></a>1797                   parent_records = records.map do |record|
</span><span class="uncovered0"><a name="line1798"></a>1798                     descendant = record.send(reflection.name)
</span><span class="uncovered1"><a name="line1799"></a>1799                     next unless descendant
</span><span class="uncovered0"><a name="line1800"></a>1800                     descendant.target.uniq! if is_collection
</span><span class="uncovered1"><a name="line1801"></a>1801                     descendant
</span><span class="uncovered0"><a name="line1802"></a>1802                   end.flatten.compact
</span><span class="uncovered1"><a name="line1803"></a>1803 
</span><span class="uncovered0"><a name="line1804"></a>1804                   remove_duplicate_results!(reflection.class_name.constantize, parent_records, associations[name]) unless parent_records.empty?
</span><span class="uncovered1"><a name="line1805"></a>1805                 end
</span><span class="uncovered0"><a name="line1806"></a>1806             end
</span><span class="uncovered1"><a name="line1807"></a>1807           end
</span><span class="inferred0"><a name="line1808"></a>1808 
</span><span class="marked1"><a name="line1809"></a>1809           def join_for_table_name(table_name)
</span><span class="uncovered0"><a name="line1810"></a>1810             join = (@joins.select{|j|j.aliased_table_name == table_name.gsub(/^\&quot;(.*)\&quot;$/){$1} }.first) rescue nil
</span><span class="uncovered1"><a name="line1811"></a>1811             return join unless join.nil?
</span><span class="uncovered0"><a name="line1812"></a>1812             @joins.select{|j|j.is_a?(JoinAssociation) &amp;&amp; j.aliased_join_table_name == table_name.gsub(/^\&quot;(.*)\&quot;$/){$1} }.first rescue nil
</span><span class="uncovered1"><a name="line1813"></a>1813           end
</span><span class="inferred0"><a name="line1814"></a>1814 
</span><span class="marked1"><a name="line1815"></a>1815           def joins_for_table_name(table_name)
</span><span class="uncovered0"><a name="line1816"></a>1816             join = join_for_table_name(table_name)
</span><span class="uncovered1"><a name="line1817"></a>1817             result = nil
</span><span class="uncovered0"><a name="line1818"></a>1818             if join &amp;&amp; join.is_a?(JoinAssociation)
</span><span class="uncovered1"><a name="line1819"></a>1819               result = [join]
</span><span class="uncovered0"><a name="line1820"></a>1820               if join.parent &amp;&amp; join.parent.is_a?(JoinAssociation)
</span><span class="uncovered1"><a name="line1821"></a>1821                 result = joins_for_table_name(join.parent.aliased_table_name) +
</span><span class="uncovered0"><a name="line1822"></a>1822                          result
</span><span class="uncovered1"><a name="line1823"></a>1823               end
</span><span class="uncovered0"><a name="line1824"></a>1824             end
</span><span class="uncovered1"><a name="line1825"></a>1825             result
</span><span class="uncovered0"><a name="line1826"></a>1826           end
</span><span class="inferred1"><a name="line1827"></a>1827 
</span><span class="marked0"><a name="line1828"></a>1828           protected
</span><span class="marked1"><a name="line1829"></a>1829             def build(associations, parent = nil)
</span><span class="uncovered0"><a name="line1830"></a>1830               parent ||= @joins.last
</span><span class="uncovered1"><a name="line1831"></a>1831               case associations
</span><span class="uncovered0"><a name="line1832"></a>1832                 when Symbol, String
</span><span class="uncovered1"><a name="line1833"></a>1833                   reflection = parent.reflections[associations.to_s.intern] or
</span><span class="uncovered0"><a name="line1834"></a>1834                   raise ConfigurationError, &quot;Association named '#{ associations }' was not found; perhaps you misspelled it?&quot;
</span><span class="uncovered1"><a name="line1835"></a>1835                   @reflections &lt;&lt; reflection
</span><span class="uncovered0"><a name="line1836"></a>1836                   @joins &lt;&lt; build_join_association(reflection, parent)
</span><span class="uncovered1"><a name="line1837"></a>1837                 when Array
</span><span class="uncovered0"><a name="line1838"></a>1838                   associations.each do |association|
</span><span class="uncovered1"><a name="line1839"></a>1839                     build(association, parent)
</span><span class="uncovered0"><a name="line1840"></a>1840                   end
</span><span class="uncovered1"><a name="line1841"></a>1841                 when Hash
</span><span class="uncovered0"><a name="line1842"></a>1842                   associations.keys.sort{|a,b|a.to_s&lt;=&gt;b.to_s}.each do |name|
</span><span class="uncovered1"><a name="line1843"></a>1843                     build(name, parent)
</span><span class="uncovered0"><a name="line1844"></a>1844                     build(associations[name])
</span><span class="uncovered1"><a name="line1845"></a>1845                   end
</span><span class="uncovered0"><a name="line1846"></a>1846                 else
</span><span class="uncovered1"><a name="line1847"></a>1847                   raise ConfigurationError, associations.inspect
</span><span class="uncovered0"><a name="line1848"></a>1848               end
</span><span class="uncovered1"><a name="line1849"></a>1849             end
</span><span class="inferred0"><a name="line1850"></a>1850 
</span><span class="inferred1"><a name="line1851"></a>1851             # overridden in InnerJoinDependency subclass
</span><span class="marked0"><a name="line1852"></a>1852             def build_join_association(reflection, parent)
</span><span class="uncovered1"><a name="line1853"></a>1853               JoinAssociation.new(reflection, self, parent)
</span><span class="uncovered0"><a name="line1854"></a>1854             end
</span><span class="inferred1"><a name="line1855"></a>1855 
</span><span class="marked0"><a name="line1856"></a>1856             def construct(parent, associations, joins, row)
</span><span class="uncovered1"><a name="line1857"></a>1857               case associations
</span><span class="uncovered0"><a name="line1858"></a>1858                 when Symbol, String
</span><span class="uncovered1"><a name="line1859"></a>1859                   join = joins.detect{|j| j.reflection.name.to_s == associations.to_s &amp;&amp; j.parent_table_name == parent.class.table_name }
</span><span class="uncovered0"><a name="line1860"></a>1860                   raise(ConfigurationError, &quot;No such association&quot;) if join.nil?
</span><span class="uncovered1"><a name="line1861"></a>1861 
</span><span class="uncovered0"><a name="line1862"></a>1862                   joins.delete(join)
</span><span class="uncovered1"><a name="line1863"></a>1863                   construct_association(parent, join, row)
</span><span class="uncovered0"><a name="line1864"></a>1864                 when Array
</span><span class="uncovered1"><a name="line1865"></a>1865                   associations.each do |association|
</span><span class="uncovered0"><a name="line1866"></a>1866                     construct(parent, association, joins, row)
</span><span class="uncovered1"><a name="line1867"></a>1867                   end
</span><span class="uncovered0"><a name="line1868"></a>1868                 when Hash
</span><span class="uncovered1"><a name="line1869"></a>1869                   associations.keys.sort{|a,b|a.to_s&lt;=&gt;b.to_s}.each do |name|
</span><span class="uncovered0"><a name="line1870"></a>1870                     join = joins.detect{|j| j.reflection.name.to_s == name.to_s &amp;&amp; j.parent_table_name == parent.class.table_name }
</span><span class="uncovered1"><a name="line1871"></a>1871                     raise(ConfigurationError, &quot;No such association&quot;) if join.nil?
</span><span class="uncovered0"><a name="line1872"></a>1872 
</span><span class="uncovered1"><a name="line1873"></a>1873                     association = construct_association(parent, join, row)
</span><span class="uncovered0"><a name="line1874"></a>1874                     joins.delete(join)
</span><span class="uncovered1"><a name="line1875"></a>1875                     construct(association, associations[name], joins, row) if association
</span><span class="uncovered0"><a name="line1876"></a>1876                   end
</span><span class="uncovered1"><a name="line1877"></a>1877                 else
</span><span class="uncovered0"><a name="line1878"></a>1878                   raise ConfigurationError, associations.inspect
</span><span class="uncovered1"><a name="line1879"></a>1879               end
</span><span class="uncovered0"><a name="line1880"></a>1880             end
</span><span class="inferred1"><a name="line1881"></a>1881 
</span><span class="marked0"><a name="line1882"></a>1882             def construct_association(record, join, row)
</span><span class="uncovered1"><a name="line1883"></a>1883               case join.reflection.macro
</span><span class="uncovered0"><a name="line1884"></a>1884                 when :has_many, :has_and_belongs_to_many
</span><span class="uncovered1"><a name="line1885"></a>1885                   collection = record.send(join.reflection.name)
</span><span class="uncovered0"><a name="line1886"></a>1886                   collection.loaded
</span><span class="uncovered1"><a name="line1887"></a>1887 
</span><span class="uncovered0"><a name="line1888"></a>1888                   return nil if record.id.to_s != join.parent.record_id(row).to_s or row[join.aliased_primary_key].nil?
</span><span class="uncovered1"><a name="line1889"></a>1889                   association = join.instantiate(row)
</span><span class="uncovered0"><a name="line1890"></a>1890                   collection.target.push(association)
</span><span class="uncovered1"><a name="line1891"></a>1891                 when :has_one
</span><span class="uncovered0"><a name="line1892"></a>1892                   return if record.id.to_s != join.parent.record_id(row).to_s
</span><span class="uncovered1"><a name="line1893"></a>1893                   return if record.instance_variable_defined?(&quot;@#{join.reflection.name}&quot;)
</span><span class="uncovered0"><a name="line1894"></a>1894                   association = join.instantiate(row) unless row[join.aliased_primary_key].nil?
</span><span class="uncovered1"><a name="line1895"></a>1895                   record.send(&quot;set_#{join.reflection.name}_target&quot;, association)
</span><span class="uncovered0"><a name="line1896"></a>1896                 when :belongs_to
</span><span class="uncovered1"><a name="line1897"></a>1897                   return if record.id.to_s != join.parent.record_id(row).to_s or row[join.aliased_primary_key].nil?
</span><span class="uncovered0"><a name="line1898"></a>1898                   association = join.instantiate(row)
</span><span class="uncovered1"><a name="line1899"></a>1899                   record.send(&quot;set_#{join.reflection.name}_target&quot;, association)
</span><span class="uncovered0"><a name="line1900"></a>1900                 else
</span><span class="uncovered1"><a name="line1901"></a>1901                   raise ConfigurationError, &quot;unknown macro: #{join.reflection.macro}&quot;
</span><span class="uncovered0"><a name="line1902"></a>1902               end
</span><span class="uncovered1"><a name="line1903"></a>1903               return association
</span><span class="uncovered0"><a name="line1904"></a>1904             end
</span><span class="inferred1"><a name="line1905"></a>1905 
</span><span class="marked0"><a name="line1906"></a>1906           class JoinBase # :nodoc:
</span><span class="marked1"><a name="line1907"></a>1907             attr_reader :active_record, :table_joins
</span><span class="marked0"><a name="line1908"></a>1908             delegate    :table_name, :column_names, :primary_key, :reflections, :sanitize_sql, :to =&gt; :active_record
</span><span class="inferred1"><a name="line1909"></a>1909 
</span><span class="marked0"><a name="line1910"></a>1910             def initialize(active_record, joins = nil)
</span><span class="uncovered1"><a name="line1911"></a>1911               @active_record = active_record
</span><span class="uncovered0"><a name="line1912"></a>1912               @cached_record = {}
</span><span class="uncovered1"><a name="line1913"></a>1913               @table_joins   = joins
</span><span class="uncovered0"><a name="line1914"></a>1914             end
</span><span class="inferred1"><a name="line1915"></a>1915 
</span><span class="marked0"><a name="line1916"></a>1916             def aliased_prefix
</span><span class="uncovered1"><a name="line1917"></a>1917               &quot;t0&quot;
</span><span class="uncovered0"><a name="line1918"></a>1918             end
</span><span class="inferred1"><a name="line1919"></a>1919 
</span><span class="marked0"><a name="line1920"></a>1920             def aliased_primary_key
</span><span class="uncovered1"><a name="line1921"></a>1921               &quot;#{aliased_prefix}_r0&quot;
</span><span class="uncovered0"><a name="line1922"></a>1922             end
</span><span class="inferred1"><a name="line1923"></a>1923 
</span><span class="marked0"><a name="line1924"></a>1924             def aliased_table_name
</span><span class="uncovered1"><a name="line1925"></a>1925               active_record.table_name
</span><span class="uncovered0"><a name="line1926"></a>1926             end
</span><span class="inferred1"><a name="line1927"></a>1927 
</span><span class="marked0"><a name="line1928"></a>1928             def column_names_with_alias
</span><span class="uncovered1"><a name="line1929"></a>1929               unless defined?(@column_names_with_alias)
</span><span class="uncovered0"><a name="line1930"></a>1930                 @column_names_with_alias = []
</span><span class="uncovered1"><a name="line1931"></a>1931 
</span><span class="uncovered0"><a name="line1932"></a>1932                 ([primary_key] + (column_names - [primary_key])).each_with_index do |column_name, i|
</span><span class="uncovered1"><a name="line1933"></a>1933                   @column_names_with_alias &lt;&lt; [column_name, &quot;#{aliased_prefix}_r#{i}&quot;]
</span><span class="uncovered0"><a name="line1934"></a>1934                 end
</span><span class="uncovered1"><a name="line1935"></a>1935               end
</span><span class="uncovered0"><a name="line1936"></a>1936 
</span><span class="uncovered1"><a name="line1937"></a>1937               @column_names_with_alias
</span><span class="uncovered0"><a name="line1938"></a>1938             end
</span><span class="inferred1"><a name="line1939"></a>1939 
</span><span class="marked0"><a name="line1940"></a>1940             def extract_record(row)
</span><span class="uncovered1"><a name="line1941"></a>1941               column_names_with_alias.inject({}){|record, (cn, an)| record[cn] = row[an]; record}
</span><span class="uncovered0"><a name="line1942"></a>1942             end
</span><span class="inferred1"><a name="line1943"></a>1943 
</span><span class="marked0"><a name="line1944"></a>1944             def record_id(row)
</span><span class="uncovered1"><a name="line1945"></a>1945               row[aliased_primary_key]
</span><span class="uncovered0"><a name="line1946"></a>1946             end
</span><span class="inferred1"><a name="line1947"></a>1947 
</span><span class="marked0"><a name="line1948"></a>1948             def instantiate(row)
</span><span class="uncovered1"><a name="line1949"></a>1949               @cached_record[record_id(row)] ||= active_record.send(:instantiate, extract_record(row))
</span><span class="uncovered0"><a name="line1950"></a>1950             end
</span><span class="uncovered1"><a name="line1951"></a>1951           end
</span><span class="inferred0"><a name="line1952"></a>1952 
</span><span class="marked1"><a name="line1953"></a>1953           class JoinAssociation &lt; JoinBase # :nodoc:
</span><span class="marked0"><a name="line1954"></a>1954             attr_reader :reflection, :parent, :aliased_table_name, :aliased_prefix, :aliased_join_table_name, :parent_table_name
</span><span class="marked1"><a name="line1955"></a>1955             delegate    :options, :klass, :through_reflection, :source_reflection, :to =&gt; :reflection
</span><span class="inferred0"><a name="line1956"></a>1956 
</span><span class="marked1"><a name="line1957"></a>1957             def initialize(reflection, join_dependency, parent = nil)
</span><span class="uncovered0"><a name="line1958"></a>1958               reflection.check_validity!
</span><span class="uncovered1"><a name="line1959"></a>1959               if reflection.options[:polymorphic]
</span><span class="uncovered0"><a name="line1960"></a>1960                 raise EagerLoadPolymorphicError.new(reflection)
</span><span class="uncovered1"><a name="line1961"></a>1961               end
</span><span class="uncovered0"><a name="line1962"></a>1962 
</span><span class="uncovered1"><a name="line1963"></a>1963               super(reflection.klass)
</span><span class="uncovered0"><a name="line1964"></a>1964               @join_dependency    = join_dependency
</span><span class="uncovered1"><a name="line1965"></a>1965               @parent             = parent
</span><span class="uncovered0"><a name="line1966"></a>1966               @reflection         = reflection
</span><span class="uncovered1"><a name="line1967"></a>1967               @aliased_prefix     = &quot;t#{ join_dependency.joins.size }&quot;
</span><span class="uncovered0"><a name="line1968"></a>1968               @parent_table_name  = parent.active_record.table_name
</span><span class="uncovered1"><a name="line1969"></a>1969               @aliased_table_name = aliased_table_name_for(table_name)
</span><span class="uncovered0"><a name="line1970"></a>1970 
</span><span class="uncovered1"><a name="line1971"></a>1971               if reflection.macro == :has_and_belongs_to_many
</span><span class="uncovered0"><a name="line1972"></a>1972                 @aliased_join_table_name = aliased_table_name_for(reflection.options[:join_table], &quot;_join&quot;)
</span><span class="uncovered1"><a name="line1973"></a>1973               end
</span><span class="uncovered0"><a name="line1974"></a>1974 
</span><span class="uncovered1"><a name="line1975"></a>1975               if [:has_many, :has_one].include?(reflection.macro) &amp;&amp; reflection.options[:through]
</span><span class="uncovered0"><a name="line1976"></a>1976                 @aliased_join_table_name = aliased_table_name_for(reflection.through_reflection.klass.table_name, &quot;_join&quot;)
</span><span class="uncovered1"><a name="line1977"></a>1977               end
</span><span class="uncovered0"><a name="line1978"></a>1978             end
</span><span class="inferred1"><a name="line1979"></a>1979 
</span><span class="marked0"><a name="line1980"></a>1980             def association_join
</span><span class="uncovered1"><a name="line1981"></a>1981               connection = reflection.active_record.connection
</span><span class="uncovered0"><a name="line1982"></a>1982               join = case reflection.macro
</span><span class="uncovered1"><a name="line1983"></a>1983                 when :has_and_belongs_to_many
</span><span class="uncovered0"><a name="line1984"></a>1984                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line1985"></a>1985                      table_alias_for(options[:join_table], aliased_join_table_name),
</span><span class="uncovered0"><a name="line1986"></a>1986                      connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line1987"></a>1987                      options[:foreign_key] || reflection.active_record.to_s.foreign_key,
</span><span class="uncovered0"><a name="line1988"></a>1988                      connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered1"><a name="line1989"></a>1989                      reflection.active_record.primary_key] +
</span><span class="uncovered0"><a name="line1990"></a>1990                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line1991"></a>1991                      table_name_and_alias,
</span><span class="uncovered0"><a name="line1992"></a>1992                      connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line1993"></a>1993                      klass.primary_key,
</span><span class="uncovered0"><a name="line1994"></a>1994                      connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line1995"></a>1995                      options[:association_foreign_key] || klass.to_s.foreign_key
</span><span class="uncovered0"><a name="line1996"></a>1996                      ]
</span><span class="uncovered1"><a name="line1997"></a>1997                 when :has_many, :has_one
</span><span class="uncovered0"><a name="line1998"></a>1998                   case
</span><span class="uncovered1"><a name="line1999"></a>1999                     when reflection.options[:through]
</span><span class="uncovered0"><a name="line2000"></a>2000                       through_conditions = through_reflection.options[:conditions] ? &quot;AND #{interpolate_sql(sanitize_sql(through_reflection.options[:conditions]))}&quot; : ''
</span><span class="uncovered1"><a name="line2001"></a>2001 
</span><span class="uncovered0"><a name="line2002"></a>2002                       jt_foreign_key = jt_as_extra = jt_source_extra = jt_sti_extra = nil
</span><span class="uncovered1"><a name="line2003"></a>2003                       first_key = second_key = as_extra = nil
</span><span class="uncovered0"><a name="line2004"></a>2004 
</span><span class="uncovered1"><a name="line2005"></a>2005                       if through_reflection.options[:as] # has_many :through against a polymorphic join
</span><span class="uncovered0"><a name="line2006"></a>2006                         jt_foreign_key = through_reflection.options[:as].to_s + '_id'
</span><span class="uncovered1"><a name="line2007"></a>2007                         jt_as_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line2008"></a>2008                           connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line2009"></a>2009                           connection.quote_column_name(through_reflection.options[:as].to_s + '_type'),
</span><span class="uncovered0"><a name="line2010"></a>2010                           klass.quote_value(parent.active_record.base_class.name)
</span><span class="uncovered1"><a name="line2011"></a>2011                         ]
</span><span class="uncovered0"><a name="line2012"></a>2012                       else
</span><span class="uncovered1"><a name="line2013"></a>2013                         jt_foreign_key = through_reflection.primary_key_name
</span><span class="uncovered0"><a name="line2014"></a>2014                       end
</span><span class="uncovered1"><a name="line2015"></a>2015 
</span><span class="uncovered0"><a name="line2016"></a>2016                       case source_reflection.macro
</span><span class="uncovered1"><a name="line2017"></a>2017                       when :has_many
</span><span class="uncovered0"><a name="line2018"></a>2018                         if source_reflection.options[:as]
</span><span class="uncovered1"><a name="line2019"></a>2019                           first_key   = &quot;#{source_reflection.options[:as]}_id&quot;
</span><span class="uncovered0"><a name="line2020"></a>2020                           second_key  = options[:foreign_key] || primary_key
</span><span class="uncovered1"><a name="line2021"></a>2021                           as_extra    = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line2022"></a>2022                             connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line2023"></a>2023                             connection.quote_column_name(&quot;#{source_reflection.options[:as]}_type&quot;),
</span><span class="uncovered0"><a name="line2024"></a>2024                             klass.quote_value(source_reflection.active_record.base_class.name)
</span><span class="uncovered1"><a name="line2025"></a>2025                           ]
</span><span class="uncovered0"><a name="line2026"></a>2026                         else
</span><span class="uncovered1"><a name="line2027"></a>2027                           first_key   = through_reflection.klass.base_class.to_s.foreign_key
</span><span class="uncovered0"><a name="line2028"></a>2028                           second_key  = options[:foreign_key] || primary_key
</span><span class="uncovered1"><a name="line2029"></a>2029                         end
</span><span class="uncovered0"><a name="line2030"></a>2030 
</span><span class="uncovered1"><a name="line2031"></a>2031                         unless through_reflection.klass.descends_from_active_record?
</span><span class="uncovered0"><a name="line2032"></a>2032                           jt_sti_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered1"><a name="line2033"></a>2033                             connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line2034"></a>2034                             connection.quote_column_name(through_reflection.active_record.inheritance_column),
</span><span class="uncovered1"><a name="line2035"></a>2035                             through_reflection.klass.quote_value(through_reflection.klass.sti_name)]
</span><span class="uncovered0"><a name="line2036"></a>2036                         end
</span><span class="uncovered1"><a name="line2037"></a>2037                       when :belongs_to
</span><span class="uncovered0"><a name="line2038"></a>2038                         first_key = primary_key
</span><span class="uncovered1"><a name="line2039"></a>2039                         if reflection.options[:source_type]
</span><span class="uncovered0"><a name="line2040"></a>2040                           second_key = source_reflection.association_foreign_key
</span><span class="uncovered1"><a name="line2041"></a>2041                           jt_source_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line2042"></a>2042                             connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line2043"></a>2043                             connection.quote_column_name(reflection.source_reflection.options[:foreign_type]),
</span><span class="uncovered0"><a name="line2044"></a>2044                             klass.quote_value(reflection.options[:source_type])
</span><span class="uncovered1"><a name="line2045"></a>2045                           ]
</span><span class="uncovered0"><a name="line2046"></a>2046                         else
</span><span class="uncovered1"><a name="line2047"></a>2047                           second_key = source_reflection.primary_key_name
</span><span class="uncovered0"><a name="line2048"></a>2048                         end
</span><span class="uncovered1"><a name="line2049"></a>2049                       end
</span><span class="uncovered0"><a name="line2050"></a>2050 
</span><span class="uncovered1"><a name="line2051"></a>2051                       &quot; #{join_type} %s ON (%s.%s = %s.%s%s%s%s) &quot; % [
</span><span class="uncovered0"><a name="line2052"></a>2052                         table_alias_for(through_reflection.klass.table_name, aliased_join_table_name),
</span><span class="uncovered1"><a name="line2053"></a>2053                         connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered0"><a name="line2054"></a>2054                         connection.quote_column_name(parent.primary_key),
</span><span class="uncovered1"><a name="line2055"></a>2055                         connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line2056"></a>2056                         connection.quote_column_name(jt_foreign_key),
</span><span class="uncovered1"><a name="line2057"></a>2057                         jt_as_extra, jt_source_extra, jt_sti_extra
</span><span class="uncovered0"><a name="line2058"></a>2058                       ] +
</span><span class="uncovered1"><a name="line2059"></a>2059                       &quot; #{join_type} %s ON (%s.%s = %s.%s%s) &quot; % [
</span><span class="uncovered0"><a name="line2060"></a>2060                         table_name_and_alias,
</span><span class="uncovered1"><a name="line2061"></a>2061                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line2062"></a>2062                         connection.quote_column_name(first_key),
</span><span class="uncovered1"><a name="line2063"></a>2063                         connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line2064"></a>2064                         connection.quote_column_name(second_key),
</span><span class="uncovered1"><a name="line2065"></a>2065                         as_extra
</span><span class="uncovered0"><a name="line2066"></a>2066                       ]
</span><span class="uncovered1"><a name="line2067"></a>2067 
</span><span class="uncovered0"><a name="line2068"></a>2068                     when reflection.options[:as] &amp;&amp; [:has_many, :has_one].include?(reflection.macro)
</span><span class="uncovered1"><a name="line2069"></a>2069                       &quot; #{join_type} %s ON %s.%s = %s.%s AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line2070"></a>2070                         table_name_and_alias,
</span><span class="uncovered1"><a name="line2071"></a>2071                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line2072"></a>2072                         &quot;#{reflection.options[:as]}_id&quot;,
</span><span class="uncovered1"><a name="line2073"></a>2073                         connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered0"><a name="line2074"></a>2074                         parent.primary_key,
</span><span class="uncovered1"><a name="line2075"></a>2075                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line2076"></a>2076                         &quot;#{reflection.options[:as]}_type&quot;,
</span><span class="uncovered1"><a name="line2077"></a>2077                         klass.quote_value(parent.active_record.base_class.name)
</span><span class="uncovered0"><a name="line2078"></a>2078                       ]
</span><span class="uncovered1"><a name="line2079"></a>2079                     else
</span><span class="uncovered0"><a name="line2080"></a>2080                       foreign_key = options[:foreign_key] || reflection.active_record.name.foreign_key
</span><span class="uncovered1"><a name="line2081"></a>2081                       &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered0"><a name="line2082"></a>2082                         table_name_and_alias,
</span><span class="uncovered1"><a name="line2083"></a>2083                         aliased_table_name,
</span><span class="uncovered0"><a name="line2084"></a>2084                         foreign_key,
</span><span class="uncovered1"><a name="line2085"></a>2085                         parent.aliased_table_name,
</span><span class="uncovered0"><a name="line2086"></a>2086                         reflection.options[:primary_key] || parent.primary_key
</span><span class="uncovered1"><a name="line2087"></a>2087                       ]
</span><span class="uncovered0"><a name="line2088"></a>2088                   end
</span><span class="uncovered1"><a name="line2089"></a>2089                 when :belongs_to
</span><span class="uncovered0"><a name="line2090"></a>2090                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line2091"></a>2091                      table_name_and_alias,
</span><span class="uncovered0"><a name="line2092"></a>2092                      connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line2093"></a>2093                      reflection.klass.primary_key,
</span><span class="uncovered0"><a name="line2094"></a>2094                      connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered1"><a name="line2095"></a>2095                      options[:foreign_key] || reflection.primary_key_name
</span><span class="uncovered0"><a name="line2096"></a>2096                     ]
</span><span class="uncovered1"><a name="line2097"></a>2097                 else
</span><span class="uncovered0"><a name="line2098"></a>2098                   &quot;&quot;
</span><span class="uncovered1"><a name="line2099"></a>2099               end || ''
</span><span class="uncovered0"><a name="line2100"></a>2100               join &lt;&lt; %(AND %s) % [
</span><span class="uncovered1"><a name="line2101"></a>2101                 klass.send(:type_condition, aliased_table_name)] unless klass.descends_from_active_record?
</span><span class="uncovered0"><a name="line2102"></a>2102 
</span><span class="uncovered1"><a name="line2103"></a>2103               [through_reflection, reflection].each do |ref|
</span><span class="uncovered0"><a name="line2104"></a>2104                 join &lt;&lt; &quot;AND #{interpolate_sql(sanitize_sql(ref.options[:conditions]))} &quot; if ref &amp;&amp; ref.options[:conditions]
</span><span class="uncovered1"><a name="line2105"></a>2105               end
</span><span class="uncovered0"><a name="line2106"></a>2106 
</span><span class="uncovered1"><a name="line2107"></a>2107               join
</span><span class="uncovered0"><a name="line2108"></a>2108             end
</span><span class="inferred1"><a name="line2109"></a>2109 
</span><span class="marked0"><a name="line2110"></a>2110             protected
</span><span class="inferred1"><a name="line2111"></a>2111 
</span><span class="marked0"><a name="line2112"></a>2112               def aliased_table_name_for(name, suffix = nil)
</span><span class="uncovered1"><a name="line2113"></a>2113                 if !parent.table_joins.blank? &amp;&amp; parent.table_joins.to_s.downcase =~ %r{join(\s+\w+)?\s+#{active_record.connection.quote_table_name name.downcase}\son}
</span><span class="uncovered0"><a name="line2114"></a>2114                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered1"><a name="line2115"></a>2115                 end
</span><span class="uncovered0"><a name="line2116"></a>2116 
</span><span class="uncovered1"><a name="line2117"></a>2117                 unless @join_dependency.table_aliases[name].zero?
</span><span class="uncovered0"><a name="line2118"></a>2118                   # if the table name has been used, then use an alias
</span><span class="uncovered1"><a name="line2119"></a>2119                   name = active_record.connection.table_alias_for &quot;#{pluralize(reflection.name)}_#{parent_table_name}#{suffix}&quot;
</span><span class="uncovered0"><a name="line2120"></a>2120                   table_index = @join_dependency.table_aliases[name]
</span><span class="uncovered1"><a name="line2121"></a>2121                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered0"><a name="line2122"></a>2122                   name = name[0..active_record.connection.table_alias_length-3] + &quot;_#{table_index+1}&quot; if table_index &gt; 0
</span><span class="uncovered1"><a name="line2123"></a>2123                 else
</span><span class="uncovered0"><a name="line2124"></a>2124                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered1"><a name="line2125"></a>2125                 end
</span><span class="uncovered0"><a name="line2126"></a>2126 
</span><span class="uncovered1"><a name="line2127"></a>2127                 name
</span><span class="uncovered0"><a name="line2128"></a>2128               end
</span><span class="inferred1"><a name="line2129"></a>2129 
</span><span class="marked0"><a name="line2130"></a>2130               def pluralize(table_name)
</span><span class="uncovered1"><a name="line2131"></a>2131                 ActiveRecord::Base.pluralize_table_names ? table_name.to_s.pluralize : table_name
</span><span class="uncovered0"><a name="line2132"></a>2132               end
</span><span class="inferred1"><a name="line2133"></a>2133 
</span><span class="marked0"><a name="line2134"></a>2134               def table_alias_for(table_name, table_alias)
</span><span class="uncovered1"><a name="line2135"></a>2135                  &quot;#{reflection.active_record.connection.quote_table_name(table_name)} #{table_alias if table_name != table_alias}&quot;.strip
</span><span class="uncovered0"><a name="line2136"></a>2136               end
</span><span class="inferred1"><a name="line2137"></a>2137 
</span><span class="marked0"><a name="line2138"></a>2138               def table_name_and_alias
</span><span class="uncovered1"><a name="line2139"></a>2139                 table_alias_for table_name, @aliased_table_name
</span><span class="uncovered0"><a name="line2140"></a>2140               end
</span><span class="inferred1"><a name="line2141"></a>2141 
</span><span class="marked0"><a name="line2142"></a>2142               def interpolate_sql(sql)
</span><span class="uncovered1"><a name="line2143"></a>2143                 instance_eval(&quot;%@#{sql.gsub('@', '\@')}@&quot;)
</span><span class="uncovered0"><a name="line2144"></a>2144               end
</span><span class="inferred1"><a name="line2145"></a>2145 
</span><span class="marked0"><a name="line2146"></a>2146             private
</span><span class="marked1"><a name="line2147"></a>2147               def join_type
</span><span class="uncovered0"><a name="line2148"></a>2148                 &quot;LEFT OUTER JOIN&quot;
</span><span class="uncovered1"><a name="line2149"></a>2149               end
</span><span class="uncovered0"><a name="line2150"></a>2150           end
</span><span class="uncovered1"><a name="line2151"></a>2151         end
</span><span class="inferred0"><a name="line2152"></a>2152 
</span><span class="marked1"><a name="line2153"></a>2153         class InnerJoinDependency &lt; JoinDependency # :nodoc:
</span><span class="marked0"><a name="line2154"></a>2154           protected
</span><span class="marked1"><a name="line2155"></a>2155             def build_join_association(reflection, parent)
</span><span class="uncovered0"><a name="line2156"></a>2156               InnerJoinAssociation.new(reflection, self, parent)
</span><span class="uncovered1"><a name="line2157"></a>2157             end
</span><span class="inferred0"><a name="line2158"></a>2158 
</span><span class="marked1"><a name="line2159"></a>2159           class InnerJoinAssociation &lt; JoinAssociation
</span><span class="marked0"><a name="line2160"></a>2160             private
</span><span class="marked1"><a name="line2161"></a>2161               def join_type
</span><span class="uncovered0"><a name="line2162"></a>2162                 &quot;INNER JOIN&quot;
</span><span class="uncovered1"><a name="line2163"></a>2163               end
</span><span class="uncovered0"><a name="line2164"></a>2164           end
</span><span class="uncovered1"><a name="line2165"></a>2165         end
</span><span class="uncovered0"><a name="line2166"></a>2166 
</span><span class="uncovered1"><a name="line2167"></a>2167     end
</span><span class="uncovered0"><a name="line2168"></a>2168   end
</span><span class="uncovered1"><a name="line2169"></a>2169 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
